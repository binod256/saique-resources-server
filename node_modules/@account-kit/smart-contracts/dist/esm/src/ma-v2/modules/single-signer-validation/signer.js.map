{"version":3,"file":"signer.js","sourceRoot":"","sources":["../../../../../../src/ma-v2/modules/single-signer-validation/signer.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  SmartAccountSigner,\n  SigningMethods,\n  SignatureRequest,\n} from \"@aa-sdk/core\";\nimport {\n  type Address,\n  type Chain,\n  concat,\n  concatHex,\n  hashMessage,\n  hashTypedData,\n  type Hex,\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n} from \"viem\";\nimport {\n  getDefaultSingleSignerValidationModuleAddress,\n  SignatureType,\n} from \"../utils.js\";\nimport {\n  packUOSignature,\n  pack1271EOASignature,\n  isDeferredAction,\n  assertNever,\n} from \"../../utils.js\";\n\n/**\n * Creates an object with methods for generating a dummy signature, signing user operation hashes, signing messages, and signing typed data.\n *\n * @example \n \n * ```ts\n * import { singleSignerMessageSigner } from \"@account-kit/smart-contracts\";\n * import { LocalAccountSigner } from \"@aa-sdk/core\";\n *\n * const MNEMONIC = \"...\":\n * \n * const account = createModularAccountV2({ config });\n *\n * const signer = LocalAccountSigner.mnemonicToAccountSigner(MNEMONIC);\n *\n * const messageSigner = singleSignerMessageSigner(signer, chain, account.address, account.signerEntity.entityId);\n * ```\n *\n * @param {SmartAccountSigner} signer Signer to use for signing operations\n * @param {Chain} chain Chain object for the signer\n * @param {Address} accountAddress address of the smart account using this signer\n * @param {number} entityId the entity id of the signing validation\n * @param {Hex} deferredActionData optional deferred action data to prepend to the uo signatures\n * @returns {object} an object with methods for signing operations and managing signatures\n */\nexport const singleSignerMessageSigner = (\n  signer: SmartAccountSigner,\n  chain: Chain,\n  accountAddress: Address,\n  entityId: number,\n  deferredActionData?: Hex,\n) => {\n  const signingMethods: SigningMethods = {\n    prepareSign: async (\n      request: SignatureRequest,\n    ): Promise<SignatureRequest> => {\n      let hash;\n      const requestType = request.type;\n\n      switch (requestType) {\n        case \"personal_sign\":\n          hash = hashMessage(request.data);\n          break;\n\n        case \"eth_signTypedData_v4\":\n          hash = await hashTypedData(request.data);\n          break;\n\n        default:\n          return assertNever(requestType, \"Invalid signature request type\");\n      }\n\n      return {\n        type: \"eth_signTypedData_v4\",\n        data: {\n          domain: {\n            chainId: Number(chain.id),\n            verifyingContract:\n              getDefaultSingleSignerValidationModuleAddress(chain),\n            salt: concatHex([`0x${\"00\".repeat(12)}`, accountAddress]),\n          },\n          types: {\n            ReplaySafeHash: [{ name: \"hash\", type: \"bytes32\" }],\n          },\n          message: {\n            hash,\n          },\n          primaryType: \"ReplaySafeHash\",\n        },\n      };\n    },\n    formatSign: async (signature: Hex) => {\n      return pack1271EOASignature({\n        validationSignature: signature,\n        entityId,\n      });\n    },\n  };\n\n  return {\n    ...signingMethods,\n    getDummySignature: (): Hex => {\n      const sig = packUOSignature({\n        // orderedHookData: [],\n        validationSignature:\n          \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\",\n      });\n\n      return deferredActionData ? concatHex([deferredActionData, sig]) : sig;\n    },\n\n    signUserOperationHash: async (uoHash: Hex): Promise<Hex> => {\n      let sig = await signer\n        .signMessage({ raw: uoHash })\n        .then((signature: Hex) =>\n          packUOSignature({\n            // orderedHookData: [],\n            validationSignature: signature,\n          }),\n        );\n\n      if (deferredActionData) {\n        sig = concatHex([deferredActionData, sig]);\n        deferredActionData = undefined;\n      }\n\n      return sig;\n    },\n\n    // we apply the expected 1271 packing here since the account contract will expect it\n    async signMessage({ message }: { message: SignableMessage }): Promise<Hex> {\n      const { type, data } = await signingMethods.prepareSign({\n        type: \"personal_sign\",\n        data: message,\n      });\n\n      if (type !== \"eth_signTypedData_v4\") {\n        throw new Error(\"Invalid signature request type\");\n      }\n\n      const sig = await signer.signTypedData(data);\n\n      return signingMethods.formatSign(sig);\n    },\n\n    // TODO: maybe move \"sign deferred actions\" to a separate function?\n    // we don't apply the expected 1271 packing since deferred sigs use typed data sigs and don't expect the 1271 packing\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      typedDataDefinition: TypedDataDefinition<typedData, primaryType>,\n    ): Promise<Hex> => {\n      const { type, data } = await signingMethods.prepareSign({\n        type: \"eth_signTypedData_v4\",\n        data: typedDataDefinition as TypedDataDefinition,\n      });\n\n      if (type !== \"eth_signTypedData_v4\") {\n        throw new Error(\"Invalid signature request type\");\n      }\n\n      const sig = await signer.signTypedData(data);\n\n      return isDeferredAction(typedDataDefinition, accountAddress)\n        ? concat([SignatureType.EOA, sig])\n        : signingMethods.formatSign(sig);\n    },\n  };\n};\n"]}