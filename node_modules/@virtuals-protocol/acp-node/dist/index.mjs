var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@virtuals-protocol/acp-node",
      version: "0.3.0-beta.13",
      main: "./dist/index.js",
      module: "./dist/index.mjs",
      types: "./dist/index.d.ts",
      scripts: {
        test: 'echo "Error: no test specified" && exit 1',
        tsup: "tsup src/index.ts --dts --format cjs,esm --out-dir dist"
      },
      author: "",
      license: "ISC",
      description: "",
      devDependencies: {
        typescript: "^5.8.3"
      },
      dependencies: {
        "@aa-sdk/core": "^4.73.0",
        "@account-kit/infra": "^4.73.0",
        "@account-kit/smart-contracts": "^4.73.0",
        "@virtuals-protocol/acp-node": "^0.3.0-beta.9",
        ajv: "^8.17.1",
        "socket.io-client": "^4.8.1",
        tsup: "^8.5.0",
        viem: "^2.28.2"
      },
      files: [
        "dist"
      ]
    };
  }
});

// src/abis/acpAbi.ts
var ACP_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AccessControlBadConfirmation", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "bytes32", name: "neededRole", type: "bytes32" }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "BudgetSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "evaluator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "evaluatorFee",
        type: "uint256"
      }
    ],
    name: "ClaimedEvaluatorFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "providerFee",
        type: "uint256"
      }
    ],
    name: "ClaimedProviderFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "evaluator",
        type: "address"
      }
    ],
    name: "JobCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymentToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "JobPaymentTokenSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "oldPhase",
        type: "uint8"
      },
      { indexed: false, internalType: "uint8", name: "phase", type: "uint8" }
    ],
    name: "JobPhaseUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "string",
        name: "reason",
        type: "string"
      }
    ],
    name: "MemoSigned",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "content",
        type: "string"
      }
    ],
    name: "NewMemo",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableFeeCollected",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableFeeRefunded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "netAmount",
        type: "uint256"
      }
    ],
    name: "PayableFeeRequestExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeAmount",
        type: "uint256"
      }
    ],
    name: "PayableFundsEscrowed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableFundsRefunded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: false, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableRequestExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: false, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableTransferExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RefundedAdditionalFees",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RefundedBudget",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_COMPLETED",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_EVALUATION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_EXPIRED",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_NEGOTIATION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_REJECTED",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_REQUEST",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_TRANSACTION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TOTAL_PHASES",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "X402_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" },
          { internalType: "uint8", name: "phase", type: "uint8" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "address", name: "evaluator", type: "address" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          }
        ],
        internalType: "struct ACPSimple.Job",
        name: "job",
        type: "tuple"
      }
    ],
    name: "canSign",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "id", type: "uint256" }],
    name: "claimBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "confirmX402PaymentReceived",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJob",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJobWithX402",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      {
        internalType: "enum InteractionLedger.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "bool", name: "isSecured", type: "bool" },
      { internalType: "uint8", name: "nextPhase", type: "uint8" }
    ],
    name: "createMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeAmount", type: "uint256" },
      {
        internalType: "enum ACPSimple.FeeType",
        name: "feeType",
        type: "uint8"
      },
      {
        internalType: "enum InteractionLedger.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "uint8", name: "nextPhase", type: "uint8" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createPayableMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "evaluatorFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getAllMemos",
    outputs: [
      {
        components: [
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum InteractionLedger.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "bool", name: "isSecured", type: "bool" },
          { internalType: "uint8", name: "nextPhase", type: "uint8" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" }
        ],
        internalType: "struct InteractionLedger.Memo[]",
        name: "",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" }
    ],
    name: "getJobPhaseMemoIds",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getMemosForPhase",
    outputs: [
      {
        components: [
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum InteractionLedger.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "bool", name: "isSecured", type: "bool" },
          { internalType: "uint8", name: "nextPhase", type: "uint8" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" }
        ],
        internalType: "struct InteractionLedger.Memo[]",
        name: "",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPhases",
    outputs: [{ internalType: "string[7]", name: "", type: "string[7]" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "paymentTokenAddress", type: "address" },
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" },
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "isJobEvaluator",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "isPayableMemo",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "jobAdditionalFees",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "jobCounter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "jobMemoIds",
    outputs: [{ internalType: "uint256", name: "memoIds", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "jobs",
    outputs: [
      { internalType: "uint256", name: "id", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "uint256", name: "amountClaimed", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "memoCount", type: "uint256" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "address", name: "evaluator", type: "address" },
      {
        internalType: "contract IERC20",
        name: "jobPaymentToken",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "memoCounter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "memoExpiredAt",
    outputs: [{ internalType: "uint256", name: "expiredAt", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "memos",
    outputs: [
      { internalType: "string", name: "content", type: "string" },
      {
        internalType: "enum InteractionLedger.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "bool", name: "isSecured", type: "bool" },
      { internalType: "uint8", name: "nextPhase", type: "uint8" },
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "sender", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "numEvaluatorsPerJob",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "payableDetails",
    outputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeAmount", type: "uint256" },
      {
        internalType: "enum ACPSimple.FeeType",
        name: "feeType",
        type: "uint8"
      },
      { internalType: "bool", name: "isExecuted", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paymentToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformTreasury",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "callerConfirmation", type: "address" }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "setBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "jobPaymentToken_",
        type: "address"
      }
    ],
    name: "setBudgetWithPaymentToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "memoId", type: "uint256" },
      { internalType: "bool", name: "isApproved", type: "bool" },
      { internalType: "string", name: "reason", type: "string" }
    ],
    name: "signMemo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "memoId", type: "uint256" },
      { internalType: "address", name: "signer", type: "address" }
    ],
    name: "signatories",
    outputs: [{ internalType: "uint8", name: "res", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "updateEvaluatorFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" }
    ],
    name: "updatePlatformFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "withdrawEscrowedFunds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "x402PaymentDetails",
    outputs: [
      { internalType: "bool", name: "isX402", type: "bool" },
      { internalType: "bool", name: "isBudgetReceived", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var acpAbi_default = ACP_ABI;

// src/acpClient.ts
import { zeroAddress as zeroAddress2 } from "viem";
import { io } from "socket.io-client";

// src/contractClients/baseAcpContractClient.ts
import {
  createPublicClient as createPublicClient2,
  encodeFunctionData,
  erc20Abi as erc20Abi2,
  http as http2,
  keccak256,
  toEventSignature,
  toHex
} from "viem";

// src/configs/acpConfigs.ts
import { baseSepolia, base } from "@account-kit/infra";

// src/acpFare.ts
import {
  createPublicClient,
  erc20Abi,
  ethAddress,
  http,
  parseUnits
} from "viem";

// src/acpError.ts
var AcpError = class _AcpError extends Error {
  constructor(message, originalError) {
    super();
    this.message = message;
    this.name = "AcpError";
    if (originalError && typeof originalError === "object" && "stack" in originalError) {
      this.stack += `
Caused by: ${originalError.stack}`;
    }
    Object.setPrototypeOf(this, _AcpError.prototype);
  }
};
var acpError_default = AcpError;

// src/acpFare.ts
var Fare = class _Fare {
  constructor(contractAddress, decimals) {
    this.contractAddress = contractAddress;
    this.decimals = decimals;
  }
  formatAmount(amount) {
    return parseUnits(amount.toString(), this.decimals);
  }
  static fromContractAddress(_0) {
    return __async(this, arguments, function* (contractAddress, config = baseAcpConfig) {
      if (contractAddress === config.baseFare.contractAddress) {
        return config.baseFare;
      }
      const publicClient = createPublicClient({
        chain: config.chain,
        transport: http(config.rpcEndpoint)
      });
      const decimals = yield publicClient.readContract({
        address: contractAddress,
        abi: erc20Abi,
        functionName: "decimals"
      });
      return new _Fare(contractAddress, decimals);
    });
  }
};
var FareAmountBase = class {
  constructor(amount, fare) {
    this.amount = amount;
    this.fare = fare;
  }
  static fromContractAddress(_0, _1) {
    return __async(this, arguments, function* (amount, contractAddress, config = baseAcpConfig) {
      const fare = yield Fare.fromContractAddress(contractAddress, config);
      if (typeof amount === "number") {
        return new FareAmount(amount, fare);
      }
      return new FareBigInt(amount, fare);
    });
  }
};
var FareAmount = class extends FareAmountBase {
  constructor(fareAmount, fare) {
    const truncateTo6Decimals = (input) => {
      const [intPart, decPart = ""] = input.split(".");
      if (decPart === "") {
        return parseFloat(intPart);
      }
      const truncated = decPart.slice(0, 6).padEnd(6, "0");
      return parseFloat(`${intPart}.${truncated}`);
    };
    super(fare.formatAmount(truncateTo6Decimals(fareAmount.toString())), fare);
  }
  add(other) {
    if (this.fare.contractAddress !== other.fare.contractAddress) {
      throw new Error("Token addresses do not match");
    }
    return new FareBigInt(this.amount + other.amount, this.fare);
  }
};
var FareBigInt = class _FareBigInt {
  constructor(amount, fare) {
    this.amount = amount;
    this.fare = fare;
  }
  add(other) {
    if (this.fare.contractAddress !== other.fare.contractAddress) {
      throw new acpError_default("Token addresses do not match");
    }
    return new _FareBigInt(this.amount + other.amount, this.fare);
  }
};
var wethFare = new Fare("0x4200000000000000000000000000000000000006", 18);
var ethFare = new Fare(ethAddress, 18);

// src/abis/acpAbiV2.ts
var ACP_V2_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AccessControlBadConfirmation", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "bytes32", name: "neededRole", type: "bytes32" }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "implementation", type: "address" }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  { inputs: [], name: "ERC1967NonPayable", type: "error" },
  { inputs: [], name: "EnforcedPause", type: "error" },
  { inputs: [], name: "ExpectedPause", type: "error" },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  { inputs: [], name: "UUPSUnauthorizedCallContext", type: "error" },
  {
    inputs: [{ internalType: "bytes32", name: "slot", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "accountId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "accountId",
        type: "uint256"
      },
      { indexed: false, internalType: "bool", name: "isActive", type: "bool" }
    ],
    name: "AccountStatusUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "evaluator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "evaluatorFee",
        type: "uint256"
      }
    ],
    name: "ClaimedEvaluatorFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "providerFee",
        type: "uint256"
      }
    ],
    name: "ClaimedProviderFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "moduleType",
        type: "string"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldModule",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newModule",
        type: "address"
      }
    ],
    name: "ModuleUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RefundedBudget",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MODULE_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "accountManager",
    outputs: [
      { internalType: "contract IAccountManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "jobId", type: "uint256" }
    ],
    name: "canSign",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "claimBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "createAccount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "createJob",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJobWithAccount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      {
        internalType: "enum ACPTypes.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "bool", name: "isSecured", type: "bool" },
      {
        internalType: "enum ACPTypes.JobPhase",
        name: "nextPhase",
        type: "uint8"
      }
    ],
    name: "createMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeAmount", type: "uint256" },
      { internalType: "enum ACPTypes.FeeType", name: "feeType", type: "uint8" },
      {
        internalType: "enum ACPTypes.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "bool", name: "isSecured", type: "bool" },
      {
        internalType: "enum ACPTypes.JobPhase",
        name: "nextPhase",
        type: "uint8"
      }
    ],
    name: "createPayableMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "createX402Job",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createX402JobWithAccount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "defaultPaymentToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "emergencyWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "evaluatorFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "accountId", type: "uint256" }],
    name: "getAccount",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "jobCount", type: "uint256" },
          {
            internalType: "uint256",
            name: "completedJobCount",
            type: "uint256"
          },
          { internalType: "bool", name: "isActive", type: "bool" }
        ],
        internalType: "struct ACPTypes.Account",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getAllMemos",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum ACPTypes.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "bool", name: "isApproved", type: "bool" },
          { internalType: "address", name: "approvedBy", type: "address" },
          { internalType: "uint256", name: "approvedAt", type: "uint256" },
          { internalType: "bool", name: "requiresApproval", type: "bool" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "bool", name: "isSecured", type: "bool" },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "nextPhase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Memo[]",
        name: "memos",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      {
        internalType: "enum ACPTypes.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getMemosForMemoType",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum ACPTypes.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "bool", name: "isApproved", type: "bool" },
          { internalType: "address", name: "approvedBy", type: "address" },
          { internalType: "uint256", name: "approvedAt", type: "uint256" },
          { internalType: "bool", name: "requiresApproval", type: "bool" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "bool", name: "isSecured", type: "bool" },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "nextPhase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Memo[]",
        name: "memos",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "enum ACPTypes.JobPhase", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getMemosForPhaseType",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum ACPTypes.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "bool", name: "isApproved", type: "bool" },
          { internalType: "address", name: "approvedBy", type: "address" },
          { internalType: "uint256", name: "approvedAt", type: "uint256" },
          { internalType: "bool", name: "requiresApproval", type: "bool" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "bool", name: "isSecured", type: "bool" },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "nextPhase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Memo[]",
        name: "memos",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPhases",
    outputs: [{ internalType: "string[7]", name: "", type: "string[7]" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "defaultPaymentToken_",
        type: "address"
      },
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" },
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "isJobEvaluator",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "jobManager",
    outputs: [
      { internalType: "contract IJobManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "memoManager",
    outputs: [
      { internalType: "contract IMemoManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paymentManager",
    outputs: [
      { internalType: "contract IPaymentManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformTreasury",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "callerConfirmation", type: "address" }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "setBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" }
    ],
    name: "setBudgetWithPaymentToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "memoId", type: "uint256" },
      { internalType: "bool", name: "isApproved", type: "bool" },
      { internalType: "string", name: "reason", type: "string" }
    ],
    name: "signMemo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "updateAccountMetadata",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "updateEvaluatorFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "moduleType", type: "string" },
      { internalType: "address", name: "moduleAddress", type: "address" }
    ],
    name: "updateModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" },
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "updatePlatformConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newImplementation", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
var acpAbiV2_default = ACP_V2_ABI;

// src/configs/acpConfigs.ts
var V1_MAX_RETRIES = 10;
var V2_MAX_RETRIES = 3;
var AcpContractConfig2 = class {
  constructor(chain, contractAddress, baseFare, alchemyRpcUrl, acpUrl, abi, maxRetries, rpcEndpoint, x402Config) {
    this.chain = chain;
    this.contractAddress = contractAddress;
    this.baseFare = baseFare;
    this.alchemyRpcUrl = alchemyRpcUrl;
    this.acpUrl = acpUrl;
    this.abi = abi;
    this.maxRetries = maxRetries;
    this.rpcEndpoint = rpcEndpoint;
    this.x402Config = x402Config;
  }
};
var baseSepoliaAcpConfig = new AcpContractConfig2(
  baseSepolia,
  "0x8Db6B1c839Fc8f6bd35777E194677B67b4D51928",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  void 0
);
var baseSepoliaAcpX402Config = new AcpContractConfig2(
  baseSepolia,
  "0x8Db6B1c839Fc8f6bd35777E194677B67b4D51928",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  {
    url: "https://dev-acp-x402.virtuals.io"
  }
);
var baseSepoliaAcpConfigV2 = new AcpContractConfig2(
  baseSepolia,
  "0xdf54E6Ed6cD1d0632d973ADECf96597b7e87893c",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  void 0
);
var baseSepoliaAcpX402ConfigV2 = new AcpContractConfig2(
  baseSepolia,
  "0xdf54E6Ed6cD1d0632d973ADECf96597b7e87893c",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  {
    url: "https://dev-acp-x402.virtuals.io"
  }
);
var baseAcpConfig = new AcpContractConfig2(
  base,
  "0x6a1FE26D54ab0d3E1e3168f2e0c0cDa5cC0A0A4A",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  void 0
);
var baseAcpX402Config = new AcpContractConfig2(
  base,
  "0x6a1FE26D54ab0d3E1e3168f2e0c0cDa5cC0A0A4A",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  {
    url: "https://acp-x402.virtuals.io"
  }
);
var baseAcpConfigV2 = new AcpContractConfig2(
  base,
  "0xa6C9BA866992cfD7fd6460ba912bfa405adA9df0",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  void 0
);
var baseAcpX402ConfigV2 = new AcpContractConfig2(
  base,
  "0xa6C9BA866992cfD7fd6460ba912bfa405adA9df0",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  {
    url: "https://acp-x402.virtuals.io"
  }
);

// src/abis/wethAbi.ts
var WETH_ABI = [
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "src", type: "address" },
      { indexed: true, internalType: "address", name: "guy", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "dst", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "src", type: "address" },
      { indexed: true, internalType: "address", name: "dst", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "src", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Withdrawal",
    type: "event"
  },
  { payable: true, stateMutability: "payable", type: "fallback" },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "guy", type: "address" },
      { internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "deposit",
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "src", type: "address" },
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ internalType: "uint256", name: "wad", type: "uint256" }],
    name: "withdraw",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];
var wethAbi_default = WETH_ABI;

// src/abis/fiatTokenV2Abi.ts
var FIAT_TOKEN_V2_ABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "nonce",
        type: "bytes32"
      }
    ],
    name: "AuthorizationCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "nonce",
        type: "bytes32"
      }
    ],
    name: "AuthorizationUsed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "Blacklisted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newBlacklister",
        type: "address"
      }
    ],
    name: "BlacklisterChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "burner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Burn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newMasterMinter",
        type: "address"
      }
    ],
    name: "MasterMinterChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "minter",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "minter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "minterAllowedAmount",
        type: "uint256"
      }
    ],
    name: "MinterConfigured",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "oldMinter",
        type: "address"
      }
    ],
    name: "MinterRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "Pause", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newAddress",
        type: "address"
      }
    ],
    name: "PauserChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRescuer",
        type: "address"
      }
    ],
    name: "RescuerChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "UnBlacklisted",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "Unpause", type: "event" },
  {
    inputs: [],
    name: "CANCEL_AUTHORIZATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "RECEIVE_WITH_AUTHORIZATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_WITH_AUTHORIZATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "authorizer", type: "address" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" }
    ],
    name: "authorizationState",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_account", type: "address" }],
    name: "blacklist",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "blacklister",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "authorizer", type: "address" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "cancelAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "authorizer", type: "address" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "cancelAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "minter", type: "address" },
      { internalType: "uint256", name: "minterAllowedAmount", type: "uint256" }
    ],
    name: "configureMinter",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "currency",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "decrement", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "increment", type: "uint256" }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "tokenName", type: "string" },
      { internalType: "string", name: "tokenSymbol", type: "string" },
      { internalType: "string", name: "tokenCurrency", type: "string" },
      { internalType: "uint8", name: "tokenDecimals", type: "uint8" },
      { internalType: "address", name: "newMasterMinter", type: "address" },
      { internalType: "address", name: "newPauser", type: "address" },
      { internalType: "address", name: "newBlacklister", type: "address" },
      { internalType: "address", name: "newOwner", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "string", name: "newName", type: "string" }],
    name: "initializeV2",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "lostAndFound", type: "address" }
    ],
    name: "initializeV2_1",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accountsToBlacklist",
        type: "address[]"
      },
      { internalType: "string", name: "newSymbol", type: "string" }
    ],
    name: "initializeV2_2",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_account", type: "address" }],
    name: "isBlacklisted",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "isMinter",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "masterMinter",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_to", type: "address" },
      { internalType: "uint256", name: "_amount", type: "uint256" }
    ],
    name: "mint",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "minter", type: "address" }],
    name: "minterAllowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pauser",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "receiveWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "receiveWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "minter", type: "address" }],
    name: "removeMinter",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "tokenContract",
        type: "address"
      },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "rescueERC20",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "rescuer",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_account", type: "address" }],
    name: "unBlacklist",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_newBlacklister", type: "address" }
    ],
    name: "updateBlacklister",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_newMasterMinter", type: "address" }
    ],
    name: "updateMasterMinter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_newPauser", type: "address" }],
    name: "updatePauser",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newRescuer", type: "address" }],
    name: "updateRescuer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  }
];
var fiatTokenV2Abi_default = FIAT_TOKEN_V2_ABI;

// src/contractClients/baseAcpContractClient.ts
var MemoType = /* @__PURE__ */ ((MemoType3) => {
  MemoType3[MemoType3["MESSAGE"] = 0] = "MESSAGE";
  MemoType3[MemoType3["CONTEXT_URL"] = 1] = "CONTEXT_URL";
  MemoType3[MemoType3["IMAGE_URL"] = 2] = "IMAGE_URL";
  MemoType3[MemoType3["VOICE_URL"] = 3] = "VOICE_URL";
  MemoType3[MemoType3["OBJECT_URL"] = 4] = "OBJECT_URL";
  MemoType3[MemoType3["TXHASH"] = 5] = "TXHASH";
  MemoType3[MemoType3["PAYABLE_REQUEST"] = 6] = "PAYABLE_REQUEST";
  MemoType3[MemoType3["PAYABLE_TRANSFER"] = 7] = "PAYABLE_TRANSFER";
  MemoType3[MemoType3["PAYABLE_TRANSFER_ESCROW"] = 8] = "PAYABLE_TRANSFER_ESCROW";
  MemoType3[MemoType3["NOTIFICATION"] = 9] = "NOTIFICATION";
  MemoType3[MemoType3["PAYABLE_NOTIFICATION"] = 10] = "PAYABLE_NOTIFICATION";
  return MemoType3;
})(MemoType || {});
var AcpJobPhases = /* @__PURE__ */ ((AcpJobPhases3) => {
  AcpJobPhases3[AcpJobPhases3["REQUEST"] = 0] = "REQUEST";
  AcpJobPhases3[AcpJobPhases3["NEGOTIATION"] = 1] = "NEGOTIATION";
  AcpJobPhases3[AcpJobPhases3["TRANSACTION"] = 2] = "TRANSACTION";
  AcpJobPhases3[AcpJobPhases3["EVALUATION"] = 3] = "EVALUATION";
  AcpJobPhases3[AcpJobPhases3["COMPLETED"] = 4] = "COMPLETED";
  AcpJobPhases3[AcpJobPhases3["REJECTED"] = 5] = "REJECTED";
  AcpJobPhases3[AcpJobPhases3["EXPIRED"] = 6] = "EXPIRED";
  return AcpJobPhases3;
})(AcpJobPhases || {});
var BaseAcpContractClient = class {
  constructor(agentWalletAddress, config = baseAcpConfig) {
    this.agentWalletAddress = agentWalletAddress;
    this.config = config;
    this.chain = config.chain;
    this.abi = config.abi;
    this.contractAddress = config.contractAddress;
    const jobCreated = acpAbi_default.find(
      (abi) => abi.name === "JobCreated"
    );
    const signature = toEventSignature(jobCreated);
    this.jobCreatedSignature = keccak256(toHex(signature));
    this.publicClient = createPublicClient2({
      chain: this.chain,
      transport: http2(this.config.rpcEndpoint)
    });
  }
  get walletAddress() {
    return this.agentWalletAddress;
  }
  createJobWithAccount(accountId, evaluatorAddress, budgetBaseUnit, paymentTokenAddress, expiredAt, isX402Job) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: isX402Job ? "createX402JobWithAccount" : "createJobWithAccount",
        args: [
          accountId,
          evaluatorAddress,
          budgetBaseUnit,
          paymentTokenAddress,
          Math.floor(expiredAt.getTime() / 1e3)
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create job with account", error);
    }
  }
  createJob(providerAddress, evaluatorAddress, expiredAt, paymentTokenAddress, budgetBaseUnit, metadata, isX402Job) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: isX402Job ? "createX402Job" : "createJob",
        args: [
          providerAddress,
          evaluatorAddress,
          Math.floor(expiredAt.getTime() / 1e3),
          paymentTokenAddress,
          budgetBaseUnit,
          metadata
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create job", error);
    }
  }
  approveAllowance(amountBaseUnit, paymentTokenAddress = this.config.baseFare.contractAddress) {
    try {
      const data = encodeFunctionData({
        abi: erc20Abi2,
        functionName: "approve",
        args: [this.contractAddress, amountBaseUnit]
      });
      const payload = {
        data,
        contractAddress: paymentTokenAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to approve allowance", error);
    }
  }
  createPayableMemo(jobId, content, amountBaseUnit, recipient, feeAmountBaseUnit, feeType, nextPhase, type, expiredAt, token = this.config.baseFare.contractAddress, secured = true) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "createPayableMemo",
        args: [
          jobId,
          content,
          token,
          amountBaseUnit,
          recipient,
          feeAmountBaseUnit,
          feeType,
          type,
          Math.floor(expiredAt.getTime() / 1e3),
          secured,
          nextPhase
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create payable memo", error);
    }
  }
  createMemo(jobId, content, type, isSecured, nextPhase) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "createMemo",
        args: [jobId, content, type, isSecured, nextPhase]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create memo", error);
    }
  }
  signMemo(memoId, isApproved, reason) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "signMemo",
        args: [memoId, isApproved, reason]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to sign memo", error);
    }
  }
  setBudgetWithPaymentToken(jobId, budgetBaseUnit, paymentTokenAddress = this.config.baseFare.contractAddress) {
    return void 0;
  }
  updateAccountMetadata(accountId, metadata) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "updateAccountMetadata",
        args: [accountId, metadata]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to update account metadata", error);
    }
  }
  wrapEth(amountBaseUnit) {
    try {
      const data = encodeFunctionData({
        abi: wethAbi_default,
        functionName: "deposit"
      });
      const payload = {
        data,
        contractAddress: wethFare.contractAddress,
        value: amountBaseUnit
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to wrap eth", error);
    }
  }
  getX402PaymentDetails(jobId) {
    return __async(this, null, function* () {
      try {
        const result = yield this.publicClient.readContract({
          address: this.contractAddress,
          abi: this.abi,
          functionName: "x402PaymentDetails",
          args: [BigInt(jobId)]
        });
        return {
          isX402: result[0],
          isBudgetReceived: result[1]
        };
      } catch (error) {
        throw new acpError_default("Failed to get X402 payment details", error);
      }
    });
  }
  submitTransferWithAuthorization(from, to, value, validAfter, validBefore, nonce, signature) {
    return __async(this, null, function* () {
      try {
        const operations = [];
        const data = encodeFunctionData({
          abi: fiatTokenV2Abi_default,
          functionName: "transferWithAuthorization",
          args: [from, to, value, validAfter, validBefore, nonce, signature]
        });
        const payload = {
          data,
          contractAddress: this.config.baseFare.contractAddress
        };
        operations.push(payload);
        return operations;
      } catch (error) {
        throw new acpError_default("Failed to submit TransferWithAuthorization", error);
      }
    });
  }
};
var baseAcpContractClient_default = BaseAcpContractClient;

// src/interfaces.ts
var AcpMemoStatus = /* @__PURE__ */ ((AcpMemoStatus2) => {
  AcpMemoStatus2["PENDING"] = "PENDING";
  AcpMemoStatus2["APPROVED"] = "APPROVED";
  AcpMemoStatus2["REJECTED"] = "REJECTED";
  return AcpMemoStatus2;
})(AcpMemoStatus || {});
var AcpAgentSort = /* @__PURE__ */ ((AcpAgentSort2) => {
  AcpAgentSort2["SUCCESSFUL_JOB_COUNT"] = "successfulJobCount";
  AcpAgentSort2["SUCCESS_RATE"] = "successRate";
  AcpAgentSort2["UNIQUE_BUYER_COUNT"] = "uniqueBuyerCount";
  AcpAgentSort2["MINS_FROM_LAST_ONLINE"] = "minsFromLastOnlineTime";
  return AcpAgentSort2;
})(AcpAgentSort || {});
var AcpGraduationStatus = /* @__PURE__ */ ((AcpGraduationStatus2) => {
  AcpGraduationStatus2["ALL"] = "all";
  AcpGraduationStatus2["GRADUATED"] = "graduated";
  AcpGraduationStatus2["NOT_GRADUATED"] = "not_graduated";
  return AcpGraduationStatus2;
})(AcpGraduationStatus || {});
var AcpOnlineStatus = /* @__PURE__ */ ((AcpOnlineStatus2) => {
  AcpOnlineStatus2["ALL"] = "all";
  AcpOnlineStatus2["ONLINE"] = "online";
  AcpOnlineStatus2["OFFLINE"] = "offline";
  return AcpOnlineStatus2;
})(AcpOnlineStatus || {});
var PayloadType = /* @__PURE__ */ ((PayloadType2) => {
  PayloadType2["FUND_RESPONSE"] = "fund_response";
  PayloadType2["OPEN_POSITION"] = "open_position";
  PayloadType2["SWAP_TOKEN"] = "swap_token";
  PayloadType2["RESPONSE_SWAP_TOKEN"] = "response_swap_token";
  PayloadType2["CLOSE_PARTIAL_POSITION"] = "close_partial_position";
  PayloadType2["CLOSE_POSITION"] = "close_position";
  PayloadType2["POSITION_FULFILLED"] = "position_fulfilled";
  PayloadType2["CLOSE_JOB_AND_WITHDRAW"] = "close_job_and_withdraw";
  PayloadType2["UNFULFILLED_POSITION"] = "unfulfilled_position";
  return PayloadType2;
})(PayloadType || {});
var PositionDirection = /* @__PURE__ */ ((PositionDirection2) => {
  PositionDirection2["LONG"] = "long";
  PositionDirection2["SHORT"] = "short";
  return PositionDirection2;
})(PositionDirection || {});

// src/utils.ts
function tryParseJson(content) {
  try {
    return JSON.parse(content);
  } catch (error) {
    return null;
  }
}
function preparePayload(payload) {
  return typeof payload === "string" ? payload : JSON.stringify(payload);
}
function safeBase64Encode(data) {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return globalThis.btoa(data);
  }
  return Buffer.from(data).toString("base64");
}

// src/acpJobOffering.ts
import { zeroAddress } from "viem";
import Ajv from "ajv";

// src/constants.ts
import { base as base2, baseSepolia as baseSepolia2 } from "viem/chains";
var USDC_TOKEN_ADDRESS = {
  [baseSepolia2.id]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  [base2.id]: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
};
var X402AuthorizationTypes = [
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "value", type: "uint256" },
  { name: "validAfter", type: "uint256" },
  { name: "validBefore", type: "uint256" },
  { name: "nonce", type: "bytes32" }
];
var HTTP_STATUS_CODES = {
  OK: 200,
  PAYMENT_REQUIRED: 402
};

// src/acpJobOffering.ts
var AcpJobOffering = class {
  constructor(acpClient, acpContractClient, providerAddress, name, price, priceType = "fixed" /* FIXED */, requirement) {
    this.acpClient = acpClient;
    this.acpContractClient = acpContractClient;
    this.providerAddress = providerAddress;
    this.name = name;
    this.price = price;
    this.priceType = priceType;
    this.requirement = requirement;
    this.ajv = new Ajv({ allErrors: true });
  }
  initiateJob(_0, _1) {
    return __async(this, arguments, function* (serviceRequirement, evaluatorAddress, expiredAt = new Date(Date.now() + 1e3 * 60 * 60 * 24)) {
      if (this.requirement && typeof this.requirement === "object") {
        const validator = this.ajv.compile(this.requirement);
        const valid = validator(serviceRequirement);
        if (!valid) {
          throw new acpError_default(this.ajv.errorsText(validator.errors));
        }
      }
      const finalServiceRequirement = {
        name: this.name,
        requirement: serviceRequirement,
        priceValue: this.price,
        priceType: this.priceType
      };
      const fareAmount = new FareAmount(
        this.priceType === "fixed" /* FIXED */ ? this.price : 0,
        this.acpContractClient.config.baseFare
      );
      const account = yield this.acpClient.getByClientAndProvider(
        this.acpContractClient.walletAddress,
        this.providerAddress,
        this.acpContractClient
      );
      const isV1 = [
        baseSepoliaAcpConfig.contractAddress,
        baseSepoliaAcpX402Config.contractAddress,
        baseAcpConfig.contractAddress,
        baseAcpX402Config.contractAddress
      ].includes(this.acpContractClient.config.contractAddress);
      let createJobPayload;
      const chainId = this.acpContractClient.config.chain.id;
      const isUsdcPaymentToken = USDC_TOKEN_ADDRESS[chainId].toLowerCase() === fareAmount.fare.contractAddress.toLowerCase();
      const isX402Job = this.acpContractClient.config.x402Config && isUsdcPaymentToken;
      if (isV1 || !account) {
        createJobPayload = this.acpContractClient.createJob(
          this.providerAddress,
          evaluatorAddress || this.acpContractClient.walletAddress,
          expiredAt,
          fareAmount.fare.contractAddress,
          fareAmount.amount,
          "",
          isX402Job
        );
      } else {
        createJobPayload = this.acpContractClient.createJobWithAccount(
          account.id,
          evaluatorAddress || zeroAddress,
          fareAmount.amount,
          fareAmount.fare.contractAddress,
          expiredAt,
          isX402Job
        );
      }
      const { userOpHash } = yield this.acpContractClient.handleOperation([
        createJobPayload
      ]);
      const jobId = yield this.acpContractClient.getJobId(
        userOpHash,
        this.acpContractClient.walletAddress,
        this.providerAddress
      );
      const payloads = [];
      const setBudgetWithPaymentTokenPayload = this.acpContractClient.setBudgetWithPaymentToken(
        jobId,
        fareAmount.amount,
        fareAmount.fare.contractAddress
      );
      if (setBudgetWithPaymentTokenPayload) {
        payloads.push(setBudgetWithPaymentTokenPayload);
      }
      payloads.push(
        this.acpContractClient.createMemo(
          jobId,
          JSON.stringify(finalServiceRequirement),
          0 /* MESSAGE */,
          true,
          1 /* NEGOTIATION */
        )
      );
      yield this.acpContractClient.handleOperation(payloads);
      return jobId;
    });
  }
};
var acpJobOffering_default = AcpJobOffering;

// src/acpJob.ts
var AcpJob = class {
  constructor(acpClient, id, clientAddress, providerAddress, evaluatorAddress, price, priceTokenAddress, memos, phase, context, contractAddress, netPayableAmount) {
    this.acpClient = acpClient;
    this.id = id;
    this.clientAddress = clientAddress;
    this.providerAddress = providerAddress;
    this.evaluatorAddress = evaluatorAddress;
    this.price = price;
    this.priceTokenAddress = priceTokenAddress;
    this.memos = memos;
    this.phase = phase;
    this.context = context;
    this.contractAddress = contractAddress;
    this.netPayableAmount = netPayableAmount;
    this.priceType = "fixed" /* FIXED */;
    this.priceValue = 0;
    var _a;
    const content = (_a = this.memos.find(
      (m) => m.nextPhase === 1 /* NEGOTIATION */
    )) == null ? void 0 : _a.content;
    if (!content) {
      return;
    }
    const contentObj = tryParseJson(content);
    if (!contentObj) {
      return;
    }
    if (contentObj.serviceRequirement || contentObj.requirement) {
      this.requirement = contentObj.requirement || contentObj.serviceRequirement;
    }
    if (contentObj.serviceName || contentObj.name) {
      this.name = contentObj.name || contentObj.serviceName;
    }
    if (contentObj.priceType) {
      this.priceType = contentObj.priceType || "fixed" /* FIXED */;
    }
    if (contentObj.priceValue) {
      this.priceValue = contentObj.priceValue || this.price;
    }
  }
  get acpContractClient() {
    return this.acpClient.contractClientByAddress(this.contractAddress);
  }
  get config() {
    return this.acpContractClient.config;
  }
  get baseFare() {
    return this.acpContractClient.config.baseFare;
  }
  get deliverable() {
    var _a;
    return (_a = this.memos.find((m) => m.nextPhase === 4 /* COMPLETED */)) == null ? void 0 : _a.content;
  }
  get rejectionReason() {
    var _a;
    const requestMemo = this.memos.find(
      (m) => m.nextPhase === 1 /* NEGOTIATION */ && m.status === "REJECTED" /* REJECTED */
    );
    if (requestMemo) {
      return requestMemo.signedReason;
    }
    return (_a = this.memos.find((m) => m.nextPhase === 5 /* REJECTED */)) == null ? void 0 : _a.content;
  }
  get providerAgent() {
    return this.acpClient.getAgent(this.providerAddress);
  }
  get clientAgent() {
    return this.acpClient.getAgent(this.clientAddress);
  }
  get evaluatorAgent() {
    return this.acpClient.getAgent(this.evaluatorAddress);
  }
  get account() {
    return this.acpClient.getAccountByJobId(this.id, this.acpContractClient);
  }
  get latestMemo() {
    return this.memos[this.memos.length - 1];
  }
  createRequirement(content) {
    return __async(this, null, function* () {
      const operations = [];
      operations.push(
        this.acpContractClient.createMemo(
          this.id,
          content,
          0 /* MESSAGE */,
          true,
          2 /* TRANSACTION */
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  createPayableRequirement(_0, _1, _2, _3) {
    return __async(this, arguments, function* (content, type, amount, recipient, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
      const operations = [];
      if (type === 8 /* PAYABLE_TRANSFER_ESCROW */) {
        operations.push(
          this.acpContractClient.approveAllowance(
            amount.amount,
            amount.fare.contractAddress
          )
        );
      }
      const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
      operations.push(
        this.acpContractClient.createPayableMemo(
          this.id,
          content,
          amount.amount,
          recipient,
          this.priceType === "percentage" /* PERCENTAGE */ ? BigInt(Math.round(this.priceValue * 1e4)) : feeAmount.amount,
          this.priceType === "percentage" /* PERCENTAGE */ ? 3 /* PERCENTAGE_FEE */ : 0 /* NO_FEE */,
          2 /* TRANSACTION */,
          type,
          expiredAt,
          amount.fare.contractAddress
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  payAndAcceptRequirement(reason) {
    return __async(this, null, function* () {
      const memo = this.memos.find(
        (m) => m.nextPhase === 2 /* TRANSACTION */
      );
      if (!memo) {
        throw new acpError_default("No notification memo found");
      }
      const operations = [];
      const baseFareAmount = new FareAmount(this.price, this.baseFare);
      const transferAmount = memo.payableDetails ? yield FareAmountBase.fromContractAddress(
        memo.payableDetails.amount,
        memo.payableDetails.token,
        this.config
      ) : new FareAmount(0, this.baseFare);
      const totalAmount = baseFareAmount.fare.contractAddress === transferAmount.fare.contractAddress ? baseFareAmount.add(transferAmount) : baseFareAmount;
      operations.push(
        this.acpContractClient.approveAllowance(
          totalAmount.amount,
          this.baseFare.contractAddress
        )
      );
      if (baseFareAmount.fare.contractAddress !== transferAmount.fare.contractAddress) {
        operations.push(
          this.acpContractClient.approveAllowance(
            transferAmount.amount,
            transferAmount.fare.contractAddress
          )
        );
      }
      operations.push(this.acpContractClient.signMemo(memo.id, true, reason));
      operations.push(
        this.acpContractClient.createMemo(
          this.id,
          `Payment made. ${reason != null ? reason : ""}`.trim(),
          0 /* MESSAGE */,
          true,
          3 /* EVALUATION */
        )
      );
      const x402PaymentDetails = yield this.acpContractClient.getX402PaymentDetails(this.id);
      if (x402PaymentDetails.isX402) {
        yield this.performX402Payment(this.price);
      }
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  respond(accept, reason) {
    return __async(this, null, function* () {
      const memoContent = `${reason || `Job ${this.id} ${accept ? "accepted" : "rejected"}.`}`;
      if (accept) {
        yield this.accept(memoContent);
        return this.createRequirement(memoContent);
      }
      return yield this.reject(memoContent);
    });
  }
  accept(reason) {
    return __async(this, null, function* () {
      const memoContent = `Job ${this.id} accepted. ${reason || ""}`;
      const latestMemo = this.latestMemo;
      if ((latestMemo == null ? void 0 : latestMemo.nextPhase) !== 1 /* NEGOTIATION */) {
        throw new acpError_default("No request memo found");
      }
      return yield latestMemo.sign(true, memoContent);
    });
  }
  reject(reason) {
    return __async(this, null, function* () {
      const memoContent = `Job ${this.id} rejected. ${reason || ""}`;
      if (this.phase === 0 /* REQUEST */) {
        const latestMemo = this.latestMemo;
        if ((latestMemo == null ? void 0 : latestMemo.nextPhase) !== 1 /* NEGOTIATION */) {
          throw new acpError_default("No request memo found");
        }
        return yield latestMemo.sign(false, memoContent);
      }
      const operations = [];
      operations.push(
        this.acpContractClient.createMemo(
          this.id,
          memoContent,
          0 /* MESSAGE */,
          true,
          5 /* REJECTED */
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  rejectPayable() {
    return __async(this, arguments, function* (reason = "", amount, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
      const memoContent = `Job ${this.id} rejected. ${reason}`;
      const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
      const operations = [];
      operations.push(
        this.acpContractClient.approveAllowance(
          amount.amount,
          amount.fare.contractAddress
        )
      );
      operations.push(
        this.acpContractClient.createPayableMemo(
          this.id,
          memoContent,
          amount.amount,
          this.clientAddress,
          feeAmount.amount,
          0 /* NO_FEE */,
          5 /* REJECTED */,
          7 /* PAYABLE_TRANSFER */,
          expiredAt,
          amount.fare.contractAddress
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  deliver(deliverable) {
    return __async(this, null, function* () {
      var _a;
      if (((_a = this.latestMemo) == null ? void 0 : _a.nextPhase) !== 3 /* EVALUATION */) {
        throw new acpError_default("No transaction memo found");
      }
      const operations = [];
      operations.push(
        this.acpContractClient.createMemo(
          this.id,
          preparePayload(deliverable),
          0 /* MESSAGE */,
          true,
          4 /* COMPLETED */
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  deliverPayable(_0, _1) {
    return __async(this, arguments, function* (deliverable, amount, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
      var _a;
      if (((_a = this.latestMemo) == null ? void 0 : _a.nextPhase) !== 3 /* EVALUATION */) {
        throw new acpError_default("No transaction memo found");
      }
      const operations = [];
      operations.push(
        this.acpContractClient.approveAllowance(
          amount.amount,
          amount.fare.contractAddress
        )
      );
      const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
      operations.push(
        this.acpContractClient.createPayableMemo(
          this.id,
          preparePayload(deliverable),
          amount.amount,
          this.clientAddress,
          feeAmount.amount,
          0 /* NO_FEE */,
          4 /* COMPLETED */,
          7 /* PAYABLE_TRANSFER */,
          expiredAt,
          amount.fare.contractAddress
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  evaluate(accept, reason) {
    return __async(this, null, function* () {
      var _a;
      if (((_a = this.latestMemo) == null ? void 0 : _a.nextPhase) !== 4 /* COMPLETED */) {
        throw new acpError_default("No evaluation memo found");
      }
      const memo = this.latestMemo;
      yield memo.sign(accept, reason);
    });
  }
  createNotification(content) {
    return __async(this, null, function* () {
      const operations = [];
      operations.push(
        this.acpContractClient.createMemo(
          this.id,
          content,
          9 /* NOTIFICATION */,
          true,
          4 /* COMPLETED */
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  createPayableNotification(_0, _1) {
    return __async(this, arguments, function* (content, amount, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
      const operations = [];
      operations.push(
        this.acpContractClient.approveAllowance(
          amount.amount,
          amount.fare.contractAddress
        )
      );
      const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
      operations.push(
        this.acpContractClient.createPayableMemo(
          this.id,
          content,
          amount.amount,
          this.clientAddress,
          feeAmount.amount,
          0 /* NO_FEE */,
          4 /* COMPLETED */,
          10 /* PAYABLE_NOTIFICATION */,
          expiredAt,
          amount.fare.contractAddress
        )
      );
      return yield this.acpContractClient.handleOperation(operations);
    });
  }
  performX402Payment(budget) {
    return __async(this, null, function* () {
      const paymentUrl = "/acp-budget";
      const x402PayableREquirements = yield this.acpContractClient.performX402Request(
        paymentUrl,
        this.acpContractClient.getAcpVersion(),
        budget.toString()
      );
      if (!x402PayableREquirements.isPaymentRequired) {
        return;
      }
      if (!x402PayableREquirements.data.accepts.length) {
        throw new acpError_default("No X402 payment requirements found");
      }
      const requirement = x402PayableREquirements.data.accepts[0];
      const { encodedPayment, signature, message } = yield this.acpContractClient.generateX402Payment(
        {
          to: requirement.payTo,
          value: Number(requirement.maxAmountRequired),
          maxTimeoutSeconds: requirement.maxTimeoutSeconds,
          asset: requirement.asset
        },
        x402PayableREquirements.data
      );
      yield this.acpContractClient.updateJobX402Nonce(this.id, message.nonce);
      const x402Response = yield this.acpContractClient.performX402Request(
        paymentUrl,
        this.acpContractClient.getAcpVersion(),
        budget.toString(),
        encodedPayment
      );
      if (x402Response.isPaymentRequired) {
        const operations = yield this.acpContractClient.submitTransferWithAuthorization(
          message.from,
          message.to,
          BigInt(message.value),
          BigInt(message.validAfter),
          BigInt(message.validBefore),
          message.nonce,
          signature
        );
        yield this.acpContractClient.handleOperation(operations);
      }
      let waitMs = 2e3;
      const maxWaitMs = 3e4;
      let iterationCount = 0;
      const maxIterations = 10;
      while (true) {
        const x402PaymentDetails = yield this.acpContractClient.getX402PaymentDetails(this.id);
        if (x402PaymentDetails.isBudgetReceived) {
          break;
        }
        iterationCount++;
        if (iterationCount >= maxIterations) {
          throw new acpError_default("X402 payment timed out");
        }
        yield new Promise((resolve) => setTimeout(resolve, waitMs));
        waitMs = Math.min(waitMs * 2, maxWaitMs);
      }
    });
  }
};
var acpJob_default = AcpJob;

// src/acpMemo.ts
var AcpMemo = class {
  constructor(contractClient, id, type, content, nextPhase, status, senderAddress, signedReason, expiry, payableDetails, txHash, signedTxHash) {
    this.contractClient = contractClient;
    this.id = id;
    this.type = type;
    this.content = content;
    this.nextPhase = nextPhase;
    this.status = status;
    this.senderAddress = senderAddress;
    this.signedReason = signedReason;
    this.expiry = expiry;
    this.payableDetails = payableDetails;
    this.txHash = txHash;
    this.signedTxHash = signedTxHash;
    if (this.payableDetails) {
      this.payableDetails.amount = BigInt(this.payableDetails.amount);
      this.payableDetails.feeAmount = BigInt(this.payableDetails.feeAmount);
    }
    this.structuredContent = tryParseJson(this.content) || void 0;
  }
  get payloadType() {
    var _a;
    return (_a = this.structuredContent) == null ? void 0 : _a.type;
  }
  getStructuredContent() {
    return this.structuredContent;
  }
  create(jobId, isSecured = true) {
    return __async(this, null, function* () {
      return yield this.contractClient.createMemo(
        jobId,
        this.content,
        this.type,
        isSecured,
        this.nextPhase
      );
    });
  }
  sign(approved, reason) {
    return __async(this, null, function* () {
      const payload = this.contractClient.signMemo(this.id, approved, reason);
      return yield this.contractClient.handleOperation([payload]);
    });
  }
};
var acpMemo_default = AcpMemo;

// src/acpAccount.ts
var AcpAccount = class {
  constructor(contractClient, id, clientAddress, providerAddress, metadata) {
    this.contractClient = contractClient;
    this.id = id;
    this.clientAddress = clientAddress;
    this.providerAddress = providerAddress;
    this.metadata = metadata;
  }
  updateMetadata(metadata) {
    return __async(this, null, function* () {
      const hash = yield this.contractClient.updateAccountMetadata(
        this.id,
        JSON.stringify(metadata)
      );
      return hash;
    });
  }
};

// src/acpClient.ts
var { version } = require_package();
var AcpClient = class {
  constructor(options) {
    this.contractClients = Array.isArray(options.acpContractClient) ? options.acpContractClient : [options.acpContractClient];
    if (this.contractClients.length === 0) {
      throw new acpError_default("ACP contract client is required");
    }
    this.contractClients.every((client) => {
      if (client.contractAddress !== this.contractClients[0].contractAddress) {
        throw new acpError_default(
          "All contract clients must have the same agent wallet address"
        );
      }
    });
    this.onNewTask = options.onNewTask;
    this.onEvaluate = options.onEvaluate || this.defaultOnEvaluate;
    this.init();
  }
  contractClientByAddress(address) {
    if (!address) {
      return this.contractClients[0];
    }
    const result = this.contractClients.find(
      (client) => client.contractAddress === address
    );
    if (!result) {
      throw new acpError_default("ACP contract client not found");
    }
    return result;
  }
  get acpContractClient() {
    return this.contractClients[0];
  }
  get acpUrl() {
    return this.acpContractClient.config.acpUrl;
  }
  defaultOnEvaluate(job) {
    return __async(this, null, function* () {
      yield job.evaluate(true, "Evaluated by default");
    });
  }
  get walletAddress() {
    if (Array.isArray(this.acpContractClient)) {
      return this.acpContractClient[0].walletAddress;
    }
    return this.acpContractClient.walletAddress;
  }
  init() {
    return __async(this, null, function* () {
      const socket = io(this.acpUrl, {
        auth: {
          walletAddress: this.walletAddress
        },
        extraHeaders: {
          "x-sdk-version": version,
          "x-sdk-language": "node",
          "x-contract-address": this.contractClients[0].contractAddress
          // always prioritize the first client
        },
        transports: ["websocket"]
      });
      socket.on("roomJoined" /* ROOM_JOINED */, (_, callback) => {
        console.log("Joined ACP Room");
        callback(true);
      });
      socket.on(
        "onEvaluate" /* ON_EVALUATE */,
        (data, callback) => __async(this, null, function* () {
          callback(true);
          if (this.onEvaluate) {
            const job = new acpJob_default(
              this,
              data.id,
              data.clientAddress,
              data.providerAddress,
              data.evaluatorAddress,
              data.price,
              data.priceTokenAddress,
              data.memos.map((memo) => {
                return new acpMemo_default(
                  this.contractClientByAddress(data.contractAddress),
                  memo.id,
                  memo.memoType,
                  memo.content,
                  memo.nextPhase,
                  memo.status,
                  memo.senderAddress,
                  memo.signedReason,
                  memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                  memo.payableDetails,
                  memo.txHash,
                  memo.signedTxHash
                );
              }),
              data.phase,
              data.context,
              data.contractAddress,
              data.netPayableAmount
            );
            this.onEvaluate(job);
          }
        })
      );
      socket.on(
        "onNewTask" /* ON_NEW_TASK */,
        (data, callback) => __async(this, null, function* () {
          callback(true);
          if (this.onNewTask) {
            const job = new acpJob_default(
              this,
              data.id,
              data.clientAddress,
              data.providerAddress,
              data.evaluatorAddress,
              data.price,
              data.priceTokenAddress,
              data.memos.map((memo) => {
                return new acpMemo_default(
                  this.contractClientByAddress(data.contractAddress),
                  memo.id,
                  memo.memoType,
                  memo.content,
                  memo.nextPhase,
                  memo.status,
                  memo.senderAddress,
                  memo.signedReason,
                  memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                  memo.payableDetails,
                  memo.txHash,
                  memo.signedTxHash
                );
              }),
              data.phase,
              data.context,
              data.contractAddress,
              data.netPayableAmount
            );
            this.onNewTask(
              job,
              job.memos.find((m) => m.id == data.memoToSign)
            );
          }
        })
      );
      const cleanup = () => __async(this, null, function* () {
        if (socket) {
          socket.disconnect();
        }
        process.exit(0);
      });
      process.on("SIGINT", cleanup);
      process.on("SIGTERM", cleanup);
    });
  }
  browseAgents(keyword, options) {
    return __async(this, null, function* () {
      let { cluster, sort_by, top_k, graduationStatus, onlineStatus } = options;
      top_k = top_k != null ? top_k : 5;
      let url = `${this.acpUrl}/api/agents/v4/search?search=${keyword}`;
      if (sort_by && sort_by.length > 0) {
        url += `&sortBy=${sort_by.map((s) => s).join(",")}`;
      }
      if (top_k) {
        url += `&top_k=${top_k}`;
      }
      if (this.walletAddress) {
        url += `&walletAddressesToExclude=${this.walletAddress}`;
      }
      if (cluster) {
        url += `&cluster=${cluster}`;
      }
      if (graduationStatus) {
        url += `&graduationStatus=${graduationStatus}`;
      }
      if (onlineStatus) {
        url += `&onlineStatus=${onlineStatus}`;
      }
      const response = yield fetch(url);
      const data = yield response.json();
      const availableContractClientAddresses = this.contractClients.map(
        (client) => client.contractAddress.toLowerCase()
      );
      return data.data.filter(
        (agent) => agent.walletAddress.toLowerCase() !== this.walletAddress.toLowerCase()
      ).filter(
        (agent) => availableContractClientAddresses.includes(
          agent.contractAddress.toLowerCase()
        )
      ).map((agent) => {
        const acpContractClient = this.contractClients.find(
          (client) => client.contractAddress.toLowerCase() === agent.contractAddress.toLowerCase()
        );
        if (!acpContractClient) {
          throw new acpError_default("ACP contract client not found");
        }
        return {
          id: agent.id,
          name: agent.name,
          description: agent.description,
          jobOfferings: agent.jobs.map((jobs) => {
            return new acpJobOffering_default(
              this,
              acpContractClient,
              agent.walletAddress,
              jobs.name,
              jobs.priceV2.value,
              jobs.priceV2.type,
              jobs.requirement
            );
          }),
          contractAddress: agent.contractAddress,
          twitterHandle: agent.twitterHandle,
          walletAddress: agent.walletAddress,
          metrics: agent.metrics,
          resource: agent.resources
        };
      });
    });
  }
  initiateJob(_0, _1, _2, _3) {
    return __async(this, arguments, function* (providerAddress, serviceRequirement, fareAmount, evaluatorAddress, expiredAt = new Date(Date.now() + 1e3 * 60 * 60 * 24)) {
      if (providerAddress === this.walletAddress) {
        throw new acpError_default(
          "Provider address cannot be the same as the client address"
        );
      }
      const account = yield this.getByClientAndProvider(
        this.walletAddress,
        providerAddress,
        this.acpContractClient
      );
      const isV1 = [
        baseSepoliaAcpConfig.contractAddress,
        baseSepoliaAcpX402Config.contractAddress,
        baseAcpConfig.contractAddress,
        baseAcpX402Config.contractAddress
      ].includes(this.acpContractClient.config.contractAddress);
      const defaultEvaluatorAddress = isV1 && !evaluatorAddress ? this.walletAddress : zeroAddress2;
      const chainId = this.acpContractClient.config.chain.id;
      const isUsdcPaymentToken = USDC_TOKEN_ADDRESS[chainId].toLowerCase() === fareAmount.fare.contractAddress.toLowerCase();
      const isX402Job = this.acpContractClient.config.x402Config && isUsdcPaymentToken;
      const createJobPayload = isV1 || !account ? this.acpContractClient.createJob(
        providerAddress,
        evaluatorAddress || defaultEvaluatorAddress,
        expiredAt,
        fareAmount.fare.contractAddress,
        fareAmount.amount,
        "",
        isX402Job
      ) : this.acpContractClient.createJobWithAccount(
        account.id,
        evaluatorAddress || defaultEvaluatorAddress,
        fareAmount.amount,
        fareAmount.fare.contractAddress,
        expiredAt,
        isX402Job
      );
      const { userOpHash } = yield this.acpContractClient.handleOperation([
        createJobPayload
      ]);
      const jobId = yield this.acpContractClient.getJobId(
        userOpHash,
        this.walletAddress,
        providerAddress
      );
      const payloads = [];
      const setBudgetWithPaymentTokenPayload = this.acpContractClient.setBudgetWithPaymentToken(
        jobId,
        fareAmount.amount,
        fareAmount.fare.contractAddress
      );
      if (setBudgetWithPaymentTokenPayload) {
        payloads.push(setBudgetWithPaymentTokenPayload);
      }
      payloads.push(
        this.acpContractClient.createMemo(
          jobId,
          preparePayload(serviceRequirement),
          0 /* MESSAGE */,
          true,
          1 /* NEGOTIATION */
        )
      );
      yield this.acpContractClient.handleOperation(payloads);
      return jobId;
    });
  }
  getActiveJobs(page = 1, pageSize = 10) {
    return __async(this, null, function* () {
      let url = `${this.acpUrl}/api/jobs/active?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
      try {
        const response = yield fetch(url, {
          headers: {
            "wallet-address": this.walletAddress
          }
        });
        const data = yield response.json();
        if (data.error) {
          throw new acpError_default(data.error.message);
        }
        return data.data.map((job) => {
          return new acpJob_default(
            this,
            job.id,
            job.clientAddress,
            job.providerAddress,
            job.evaluatorAddress,
            job.price,
            job.priceTokenAddress,
            job.memos.map((memo) => {
              return new acpMemo_default(
                this.contractClientByAddress(job.contractAddress),
                memo.id,
                memo.memoType,
                memo.content,
                memo.nextPhase,
                memo.status,
                memo.senderAddress,
                memo.signedReason,
                memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                memo.payableDetails,
                memo.txHash,
                memo.signedTxHash
              );
            }),
            job.phase,
            job.context,
            job.contractAddress,
            job.netPayableAmount
          );
        });
      } catch (error) {
        throw new acpError_default("Failed to get active jobs", error);
      }
    });
  }
  getPendingMemoJobs(page = 1, pageSize = 10) {
    return __async(this, null, function* () {
      let url = `${this.acpUrl}/api/jobs/pending-memos?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
      try {
        const response = yield fetch(url, {
          headers: {
            "wallet-address": this.acpContractClient.walletAddress
          }
        });
        const data = yield response.json();
        if (data.error) {
          throw new acpError_default(data.error.message);
        }
        return data.data.map((job) => {
          return new acpJob_default(
            this,
            job.id,
            job.clientAddress,
            job.providerAddress,
            job.evaluatorAddress,
            job.price,
            job.priceTokenAddress,
            job.memos.map((memo) => {
              return new acpMemo_default(
                this.contractClientByAddress(job.contractAddress),
                memo.id,
                memo.memoType,
                memo.content,
                memo.nextPhase,
                memo.status,
                memo.senderAddress,
                memo.signedReason,
                memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                typeof memo.payableDetails === "string" ? tryParseJson(memo.payableDetails) || void 0 : memo.payableDetails,
                memo.txHash,
                memo.signedTxHash
              );
            }),
            job.phase,
            job.context,
            job.contractAddress,
            job.netPayableAmount
          );
        });
      } catch (error) {
        throw new acpError_default("Failed to get pending memo jobs", error);
      }
    });
  }
  getCompletedJobs(page = 1, pageSize = 10) {
    return __async(this, null, function* () {
      let url = `${this.acpUrl}/api/jobs/completed?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
      try {
        const response = yield fetch(url, {
          headers: {
            "wallet-address": this.acpContractClient.walletAddress
          }
        });
        const data = yield response.json();
        if (data.error) {
          throw new acpError_default(data.error.message);
        }
        return data.data.map((job) => {
          return new acpJob_default(
            this,
            job.id,
            job.clientAddress,
            job.providerAddress,
            job.evaluatorAddress,
            job.price,
            job.priceTokenAddress,
            job.memos.map((memo) => {
              return new acpMemo_default(
                this.contractClientByAddress(job.contractAddress),
                memo.id,
                memo.memoType,
                memo.content,
                memo.nextPhase,
                memo.status,
                memo.senderAddress,
                memo.signedReason,
                memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                memo.payableDetails,
                memo.txHash,
                memo.signedTxHash
              );
            }),
            job.phase,
            job.context,
            job.contractAddress,
            job.netPayableAmount
          );
        });
      } catch (error) {
        throw new acpError_default("Failed to get completed jobs", error);
      }
    });
  }
  getCancelledJobs(page = 1, pageSize = 10) {
    return __async(this, null, function* () {
      let url = `${this.acpUrl}/api/jobs/cancelled?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
      try {
        const response = yield fetch(url, {
          headers: {
            "wallet-address": this.walletAddress
          }
        });
        const data = yield response.json();
        if (data.error) {
          throw new acpError_default(data.error.message);
        }
        return data.data.map((job) => {
          return new acpJob_default(
            this,
            job.id,
            job.clientAddress,
            job.providerAddress,
            job.evaluatorAddress,
            job.price,
            job.priceTokenAddress,
            job.memos.map((memo) => {
              return new acpMemo_default(
                this.contractClientByAddress(job.contractAddress),
                memo.id,
                memo.memoType,
                memo.content,
                memo.nextPhase,
                memo.status,
                memo.senderAddress,
                memo.signedReason,
                memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                memo.payableDetails,
                memo.txHash,
                memo.signedTxHash
              );
            }),
            job.phase,
            job.context,
            job.contractAddress,
            job.netPayableAmount
          );
        });
      } catch (error) {
        throw new acpError_default("Failed to get cancelled jobs", error);
      }
    });
  }
  getJobById(jobId) {
    return __async(this, null, function* () {
      let url = `${this.acpUrl}/api/jobs/${jobId}`;
      try {
        const response = yield fetch(url, {
          headers: {
            "wallet-address": this.acpContractClient.walletAddress
          }
        });
        const data = yield response.json();
        if (data.error) {
          throw new acpError_default(data.error.message);
        }
        const job = data.data;
        if (!job) {
          return;
        }
        return new acpJob_default(
          this,
          job.id,
          job.clientAddress,
          job.providerAddress,
          job.evaluatorAddress,
          job.price,
          job.priceTokenAddress,
          job.memos.map((memo) => {
            return new acpMemo_default(
              this.contractClientByAddress(job.contractAddress),
              memo.id,
              memo.memoType,
              memo.content,
              memo.nextPhase,
              memo.status,
              memo.senderAddress,
              memo.signedReason,
              memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
              memo.payableDetails,
              memo.txHash,
              memo.signedTxHash
            );
          }),
          job.phase,
          job.context,
          job.contractAddress,
          job.netPayableAmount
        );
      } catch (error) {
        throw new acpError_default("Failed to get job by id", error);
      }
    });
  }
  getMemoById(jobId, memoId) {
    return __async(this, null, function* () {
      let url = `${this.acpUrl}/api/jobs/${jobId}/memos/${memoId}`;
      try {
        const response = yield fetch(url, {
          headers: {
            "wallet-address": this.walletAddress
          }
        });
        const data = yield response.json();
        if (data.error) {
          throw new acpError_default(data.error.message);
        }
        const memo = data.data;
        if (!memo) {
          return;
        }
        return new acpMemo_default(
          this.contractClientByAddress(memo.contractAddress),
          memo.id,
          memo.memoType,
          memo.content,
          memo.nextPhase,
          memo.status,
          memo.senderAddress,
          memo.signedReason,
          memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
          memo.payableDetails,
          memo.txHash,
          memo.signedTxHash
        );
      } catch (error) {
        throw new acpError_default("Failed to get memo by id", error);
      }
    });
  }
  getAgent(walletAddress) {
    return __async(this, null, function* () {
      const url = `${this.acpUrl}/api/agents?filters[walletAddress]=${walletAddress}`;
      const response = yield fetch(url);
      const data = yield response.json();
      const agents = data.data || [];
      if (agents.length === 0) {
        return;
      }
      return agents[0];
    });
  }
  getAccountByJobId(jobId, acpContractClient) {
    return __async(this, null, function* () {
      try {
        const url = `${this.acpUrl}/api/accounts/job/${jobId}`;
        const response = yield fetch(url);
        const data = yield response.json();
        if (!data.data) {
          return null;
        }
        return new AcpAccount(
          acpContractClient || this.contractClients[0],
          data.data.id,
          data.data.clientAddress,
          data.data.providerAddress,
          data.data.metadata
        );
      } catch (error) {
        throw new acpError_default("Failed to get account by job id", error);
      }
    });
  }
  getByClientAndProvider(clientAddress, providerAddress, acpContractClient) {
    return __async(this, null, function* () {
      try {
        const url = `${this.acpUrl}/api/accounts/client/${clientAddress}/provider/${providerAddress}`;
        const response = yield fetch(url);
        const data = yield response.json();
        if (!data.data) {
          return null;
        }
        return new AcpAccount(
          acpContractClient || this.contractClients[0],
          data.data.id,
          data.data.clientAddress,
          data.data.providerAddress,
          data.data.metadata
        );
      } catch (error) {
        throw new acpError_default("Failed to get account by client and provider", error);
      }
    });
  }
};
var acpClient_default = AcpClient;

// src/contractClients/acpContractClient.ts
import { LocalAccountSigner } from "@aa-sdk/core";
import { alchemy } from "@account-kit/infra";
import {
  createModularAccountV2Client
} from "@account-kit/smart-contracts";
import { decodeEventLog, encodeFunctionData as encodeFunctionData3 } from "viem";

// src/acpX402.ts
import {
  erc20Abi as erc20Abi3
} from "viem";
import { randomBytes } from "crypto";
var AcpX402 = class {
  constructor(config, sessionKeyClient, publicClient) {
    this.config = config;
    this.sessionKeyClient = sessionKeyClient;
    this.publicClient = publicClient;
    this.config = config;
    this.sessionKeyClient = sessionKeyClient;
    this.publicClient = publicClient;
  }
  signUpdateJobNonceMessage(jobId, nonce) {
    return __async(this, null, function* () {
      const message = `${jobId}-${nonce}`;
      const signature = yield this.sessionKeyClient.account.getSigner().signMessage(message);
      return signature;
    });
  }
  updateJobNonce(jobId, nonce) {
    return __async(this, null, function* () {
      try {
        const apiUrl = `${this.config.acpUrl}/api/jobs/${jobId}/x402-nonce`;
        const signature = yield this.signUpdateJobNonceMessage(jobId, nonce);
        const response = yield fetch(apiUrl, {
          method: "POST",
          headers: {
            "x-signature": signature,
            "x-nonce": nonce,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            data: {
              nonce
            }
          })
        });
        if (!response.ok) {
          throw new acpError_default(
            "Failed to update job X402 nonce",
            response.statusText
          );
        }
        const acpJob = yield response.json();
        return acpJob;
      } catch (error) {
        throw new acpError_default("Failed to update job X402 nonce", error);
      }
    });
  }
  generatePayment(payableRequest, requirements) {
    return __async(this, null, function* () {
      try {
        const USDC_CONTRACT = this.config.baseFare.contractAddress;
        const timeNow = Math.floor(Date.now() / 1e3);
        const validAfter = timeNow.toString();
        const validBefore = (timeNow + requirements.accepts[0].maxTimeoutSeconds).toString();
        const [tokenName, tokenVersion] = yield this.publicClient.multicall({
          contracts: [
            {
              address: USDC_CONTRACT,
              abi: erc20Abi3,
              functionName: "name"
            },
            {
              address: USDC_CONTRACT,
              abi: fiatTokenV2Abi_default,
              functionName: "version"
            }
          ]
        });
        const nonce = `0x${randomBytes(32).toString("hex")}`;
        const message = {
          from: this.sessionKeyClient.account.address,
          to: payableRequest.to,
          value: payableRequest.value.toString(),
          validAfter: validAfter.toString(),
          validBefore: validBefore.toString(),
          nonce
        };
        const typedData = {
          types: {
            TransferWithAuthorization: X402AuthorizationTypes
          },
          domain: {
            name: tokenName.result,
            version: tokenVersion.result,
            chainId: this.config.chain.id,
            verifyingContract: USDC_CONTRACT
          },
          primaryType: "TransferWithAuthorization",
          message
        };
        const signature = yield this.sessionKeyClient.signTypedData({
          typedData
        });
        const payload = {
          x402Version: requirements.x402Version,
          scheme: requirements.accepts[0].scheme,
          network: requirements.accepts[0].network,
          payload: {
            signature,
            authorization: message
          }
        };
        const encodedPayment = safeBase64Encode(JSON.stringify(payload));
        return {
          encodedPayment,
          signature,
          message
        };
      } catch (error) {
        throw new acpError_default("Failed to generate X402 payment", error);
      }
    });
  }
  performRequest(url, version2, budget, signature) {
    return __async(this, null, function* () {
      var _a;
      const baseUrl = (_a = this.config.x402Config) == null ? void 0 : _a.url;
      if (!baseUrl) throw new acpError_default("X402 URL not configured");
      try {
        const headers = {};
        if (signature) headers["x-payment"] = signature;
        if (budget) headers["x-budget"] = budget.toString();
        headers["x-acp-version"] = version2;
        const res = yield fetch(`${baseUrl}${url}`, { method: "GET", headers });
        const data = yield res.json();
        if (!res.ok && res.status !== HTTP_STATUS_CODES.PAYMENT_REQUIRED) {
          throw new acpError_default(
            "Invalid response status code for X402 request",
            data
          );
        }
        return {
          isPaymentRequired: res.status === HTTP_STATUS_CODES.PAYMENT_REQUIRED,
          data
        };
      } catch (error) {
        throw new acpError_default("Failed to perform X402 request", error);
      }
    });
  }
};

// src/contractClients/acpContractClient.ts
var AcpContractClient = class _AcpContractClient extends baseAcpContractClient_default {
  constructor(agentWalletAddress, config = baseAcpConfig) {
    super(agentWalletAddress, config);
    this.PRIORITY_FEE_MULTIPLIER = 2;
    this.MAX_FEE_PER_GAS = 2e7;
    this.MAX_PRIORITY_FEE_PER_GAS = 21e6;
  }
  static build(_0, _1, _2) {
    return __async(this, arguments, function* (walletPrivateKey, sessionEntityKeyId, agentWalletAddress, config = baseAcpConfig) {
      const acpContractClient = new _AcpContractClient(
        agentWalletAddress,
        config
      );
      yield acpContractClient.init(walletPrivateKey, sessionEntityKeyId);
      return acpContractClient;
    });
  }
  init(privateKey, sessionEntityKeyId) {
    return __async(this, null, function* () {
      const sessionKeySigner = LocalAccountSigner.privateKeyToAccountSigner(privateKey);
      this._sessionKeyClient = yield createModularAccountV2Client({
        chain: this.chain,
        transport: alchemy({
          rpcUrl: this.config.alchemyRpcUrl
        }),
        signer: sessionKeySigner,
        policyId: "186aaa4a-5f57-4156-83fb-e456365a8820",
        accountAddress: this.agentWalletAddress,
        signerEntity: {
          entityId: sessionEntityKeyId,
          isGlobalValidation: true
        }
      });
      this._acpX402 = new AcpX402(
        this.config,
        this.sessionKeyClient,
        this.publicClient
      );
    });
  }
  getRandomNonce(bits = 152) {
    const bytes = bits / 8;
    const array = new Uint8Array(bytes);
    crypto.getRandomValues(array);
    let hex = Array.from(array, (b) => b.toString(16).padStart(2, "0")).join(
      ""
    );
    return BigInt("0x" + hex);
  }
  get sessionKeyClient() {
    if (!this._sessionKeyClient) {
      throw new acpError_default("Session key client not initialized");
    }
    return this._sessionKeyClient;
  }
  get acpX402() {
    if (!this._acpX402) {
      throw new acpError_default("ACP X402 not initialized");
    }
    return this._acpX402;
  }
  calculateGasFees() {
    return __async(this, null, function* () {
      const finalMaxFeePerGas = BigInt(this.MAX_FEE_PER_GAS) + BigInt(this.MAX_PRIORITY_FEE_PER_GAS) * BigInt(Math.max(0, this.PRIORITY_FEE_MULTIPLIER - 1));
      return finalMaxFeePerGas;
    });
  }
  handleOperation(operations) {
    return __async(this, null, function* () {
      const payload = {
        uo: operations.map((op) => ({
          target: op.contractAddress,
          data: op.data,
          value: op.value
        })),
        overrides: {
          nonceKey: this.getRandomNonce()
        }
      };
      let retries = this.config.maxRetries;
      let finalError;
      while (retries > 0) {
        try {
          if (this.config.maxRetries > retries) {
            const gasFees = yield this.calculateGasFees();
            payload["overrides"] = {
              maxFeePerGas: `0x${gasFees.toString(16)}`
            };
          }
          const { hash } = yield this.sessionKeyClient.sendUserOperation(payload);
          const txnHash = yield this.sessionKeyClient.waitForUserOperationTransaction({
            hash
          });
          return { userOpHash: hash, txnHash };
        } catch (error) {
          retries -= 1;
          if (retries === 0) {
            finalError = error;
            break;
          }
          yield new Promise((resolve) => setTimeout(resolve, 2e3 * retries));
        }
      }
      throw new acpError_default(`Failed to send user operation`, finalError);
    });
  }
  getJobId(createJobUserOpHash, clientAddress, providerAddress) {
    return __async(this, null, function* () {
      const result = yield this.sessionKeyClient.getUserOperationReceipt(createJobUserOpHash);
      if (!result) {
        throw new acpError_default("Failed to get user operation receipt");
      }
      const contractLogs = result.logs.filter((log) => {
        return log.address.toLowerCase() === this.contractAddress.toLowerCase();
      }).map(
        (log) => decodeEventLog({
          abi: this.abi,
          data: log.data,
          topics: log.topics
        })
      );
      const createdJobEvent = contractLogs.find(
        (log) => log.eventName === "JobCreated" && log.args.client.toLowerCase() === clientAddress.toLowerCase() && log.args.provider.toLowerCase() === providerAddress.toLowerCase()
      );
      if (!createdJobEvent) {
        throw new acpError_default("Failed to find created job event");
      }
      return Number(createdJobEvent.args.jobId);
    });
  }
  createJob(providerAddress, evaluatorAddress, expireAt, paymentTokenAddress, budgetBaseUnit, metadata, isX402Job) {
    try {
      const data = encodeFunctionData3({
        abi: this.abi,
        functionName: isX402Job ? "createJobWithX402" : "createJob",
        args: [
          providerAddress,
          evaluatorAddress,
          Math.floor(expireAt.getTime() / 1e3)
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create job", error);
    }
  }
  setBudgetWithPaymentToken(jobId, budgetBaseUnit, paymentTokenAddress = this.config.baseFare.contractAddress) {
    try {
      const data = encodeFunctionData3({
        abi: this.abi,
        functionName: "setBudgetWithPaymentToken",
        args: [jobId, budgetBaseUnit, paymentTokenAddress]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to set budget", error);
    }
  }
  createPayableMemo(jobId, content, amountBaseUnit, recipient, feeAmountBaseUnit, feeType, nextPhase, type, expiredAt, token = this.config.baseFare.contractAddress, secured = true) {
    try {
      const data = encodeFunctionData3({
        abi: this.abi,
        functionName: "createPayableMemo",
        args: [
          jobId,
          content,
          token,
          amountBaseUnit,
          recipient,
          feeAmountBaseUnit,
          feeType,
          type,
          nextPhase,
          Math.floor(expiredAt.getTime() / 1e3)
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create payable memo", error);
    }
  }
  createJobWithAccount(accountId, evaluatorAddress, budgetBaseUnit, paymentTokenAddress, expiredAt, isX402Job) {
    throw new acpError_default("Not Supported");
  }
  updateAccountMetadata(accountId, metadata) {
    throw new acpError_default("Not Supported");
  }
  updateJobX402Nonce(jobId, nonce) {
    return __async(this, null, function* () {
      return yield this.acpX402.updateJobNonce(jobId, nonce);
    });
  }
  generateX402Payment(payableRequest, requirements) {
    return __async(this, null, function* () {
      return yield this.acpX402.generatePayment(payableRequest, requirements);
    });
  }
  performX402Request(url, version2, budget, signature) {
    return __async(this, null, function* () {
      return yield this.acpX402.performRequest(url, version2, budget, signature);
    });
  }
  getAcpVersion() {
    return "1";
  }
};
var acpContractClient_default = AcpContractClient;

// src/contractClients/acpContractClientV2.ts
import { LocalAccountSigner as LocalAccountSigner2 } from "@aa-sdk/core";
import { alchemy as alchemy2 } from "@account-kit/infra";
import {
  createModularAccountV2Client as createModularAccountV2Client2
} from "@account-kit/smart-contracts";
import { createPublicClient as createPublicClient4, decodeEventLog as decodeEventLog2, http as http3 } from "viem";

// src/abis/jobManagerAbi.ts
var JOB_MANAGER_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AccessControlBadConfirmation", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "bytes32", name: "neededRole", type: "bytes32" }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "implementation", type: "address" }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  { inputs: [], name: "ERC1967NonPayable", type: "error" },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  { inputs: [], name: "UUPSUnauthorizedCallContext", type: "error" },
  {
    inputs: [{ internalType: "bytes32", name: "slot", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "BudgetSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "accountId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "evaluator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "expiredAt",
        type: "uint256"
      }
    ],
    name: "JobCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymentToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "JobPaymentTokenSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum ACPTypes.JobPhase",
        name: "oldPhase",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "enum ACPTypes.JobPhase",
        name: "newPhase",
        type: "uint8"
      }
    ],
    name: "JobPhaseUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      }
    ],
    name: "X402PaymentReceived",
    type: "event"
  },
  {
    inputs: [],
    name: "ACP_CONTRACT_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MEMO_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "X402_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "accountJobs",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acpContract",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "user", type: "address" }
    ],
    name: "canModifyJob",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "confirmX402PaymentReceived",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "paymentToken",
        type: "address"
      },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJob",
    outputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "paymentToken",
        type: "address"
      },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJobWithX402",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getAccountJobs",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "accountId", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "address", name: "evaluator", type: "address" },
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "phase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Job[]",
        name: "jobArray",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "getJob",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "accountId", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "address", name: "evaluator", type: "address" },
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "phase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Job",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "assignee", type: "address" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getUserJobs",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "accountId", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "address", name: "evaluator", type: "address" },
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "phase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Job[]",
        name: "jobArray",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "getX402PaymentDetails",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "isX402", type: "bool" },
          { internalType: "bool", name: "isBudgetReceived", type: "bool" }
        ],
        internalType: "struct ACPTypes.X402PaymentDetail",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "incrementMemoCount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "acpContract_", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "jobCounter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "jobs",
    outputs: [
      { internalType: "uint256", name: "id", type: "uint256" },
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "jobPaymentToken",
        type: "address"
      },
      { internalType: "enum ACPTypes.JobPhase", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "uint256", name: "createdAt", type: "uint256" },
      { internalType: "uint256", name: "memoCount", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" },
      { internalType: "uint256", name: "amountClaimed", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "callerConfirmation", type: "address" }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "paymentToken",
        type: "address"
      }
    ],
    name: "setJobBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "x402PaymentTokenAddress",
        type: "address"
      }
    ],
    name: "setX402PaymentToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "acpContract_", type: "address" }
    ],
    name: "updateContracts",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      {
        internalType: "enum ACPTypes.JobPhase",
        name: "newPhase",
        type: "uint8"
      }
    ],
    name: "updateJobPhase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newImplementation", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "userJobs",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "x402PaymentDetails",
    outputs: [
      { internalType: "bool", name: "isX402", type: "bool" },
      { internalType: "bool", name: "isBudgetReceived", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "x402PaymentToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  }
];
var jobManagerAbi_default = JOB_MANAGER_ABI;

// src/contractClients/acpContractClientV2.ts
var AcpContractClientV2 = class _AcpContractClientV2 extends baseAcpContractClient_default {
  constructor(jobManagerAddress, memoManagerAddress, accountManagerAddress, agentWalletAddress, config = baseAcpConfigV2) {
    super(agentWalletAddress, config);
    this.jobManagerAddress = jobManagerAddress;
    this.memoManagerAddress = memoManagerAddress;
    this.accountManagerAddress = accountManagerAddress;
    this.PRIORITY_FEE_MULTIPLIER = 2;
    this.MAX_FEE_PER_GAS = 2e7;
    this.MAX_PRIORITY_FEE_PER_GAS = 21e6;
  }
  static build(_0, _1, _2) {
    return __async(this, arguments, function* (walletPrivateKey, sessionEntityKeyId, agentWalletAddress, config = baseAcpConfigV2) {
      const publicClient = createPublicClient4({
        chain: config.chain,
        transport: http3(config.rpcEndpoint)
      });
      const [jobManagerAddress, memoManagerAddress, accountManagerAddress] = yield publicClient.multicall({
        contracts: [
          {
            address: config.contractAddress,
            abi: config.abi,
            functionName: "jobManager"
          },
          {
            address: config.contractAddress,
            abi: config.abi,
            functionName: "memoManager"
          },
          {
            address: config.contractAddress,
            abi: config.abi,
            functionName: "accountManager"
          }
        ]
      });
      if (!jobManagerAddress || !memoManagerAddress || !accountManagerAddress) {
        throw new acpError_default(
          "Failed to get job manager, memo manager, or account manager address"
        );
      }
      const acpContractClient = new _AcpContractClientV2(
        jobManagerAddress.result,
        memoManagerAddress.result,
        accountManagerAddress.result,
        agentWalletAddress,
        config
      );
      yield acpContractClient.init(walletPrivateKey, sessionEntityKeyId);
      return acpContractClient;
    });
  }
  init(privateKey, sessionEntityKeyId) {
    return __async(this, null, function* () {
      const sessionKeySigner = LocalAccountSigner2.privateKeyToAccountSigner(privateKey);
      this._sessionKeyClient = yield createModularAccountV2Client2({
        chain: this.chain,
        transport: alchemy2({
          rpcUrl: this.config.alchemyRpcUrl
        }),
        signer: sessionKeySigner,
        policyId: "186aaa4a-5f57-4156-83fb-e456365a8820",
        accountAddress: this.agentWalletAddress,
        signerEntity: {
          entityId: sessionEntityKeyId,
          isGlobalValidation: true
        }
      });
      this._acpX402 = new AcpX402(
        this.config,
        this.sessionKeyClient,
        this.publicClient
      );
    });
  }
  getRandomNonce(bits = 152) {
    const bytes = bits / 8;
    const array = new Uint8Array(bytes);
    crypto.getRandomValues(array);
    let hex = Array.from(array, (b) => b.toString(16).padStart(2, "0")).join(
      ""
    );
    return BigInt("0x" + hex);
  }
  get sessionKeyClient() {
    if (!this._sessionKeyClient) {
      throw new acpError_default("Session key client not initialized");
    }
    return this._sessionKeyClient;
  }
  get acpX402() {
    if (!this._acpX402) {
      throw new acpError_default("ACP X402 not initialized");
    }
    return this._acpX402;
  }
  calculateGasFees() {
    return __async(this, null, function* () {
      const finalMaxFeePerGas = BigInt(this.MAX_FEE_PER_GAS) + BigInt(this.MAX_PRIORITY_FEE_PER_GAS) * BigInt(Math.max(0, this.PRIORITY_FEE_MULTIPLIER - 1));
      return finalMaxFeePerGas;
    });
  }
  handleOperation(operations) {
    return __async(this, null, function* () {
      const payload = {
        uo: operations.map((operation) => ({
          target: operation.contractAddress,
          data: operation.data,
          value: operation.value
        })),
        overrides: {
          nonceKey: this.getRandomNonce()
        }
      };
      let retries = this.config.maxRetries;
      let finalError;
      while (retries > 0) {
        try {
          if (this.config.maxRetries > retries) {
            const gasFees = yield this.calculateGasFees();
            payload["overrides"] = {
              maxFeePerGas: `0x${gasFees.toString(16)}`
            };
          }
          const { hash } = yield this.sessionKeyClient.sendUserOperation(payload);
          const txnHash = yield this.sessionKeyClient.waitForUserOperationTransaction({
            hash,
            tag: "pending",
            retries: {
              intervalMs: 200,
              multiplier: 1.1,
              maxRetries: 10
            }
          });
          return { userOpHash: hash, txnHash };
        } catch (error) {
          retries -= 1;
          if (retries === 0) {
            finalError = error;
            break;
          }
          yield new Promise((resolve) => setTimeout(resolve, 2e3 * retries));
        }
      }
      throw new acpError_default(`Failed to send user operation`, finalError);
    });
  }
  getJobId(createJobUserOpHash, clientAddress, providerAddress) {
    return __async(this, null, function* () {
      const result = yield this.sessionKeyClient.getUserOperationReceipt(
        createJobUserOpHash,
        "pending"
      );
      if (!result) {
        throw new acpError_default("Failed to get user operation receipt");
      }
      const contractLogs = result.logs.filter((log) => {
        return log.address.toLowerCase() === this.jobManagerAddress.toLowerCase();
      }).map(
        (log) => decodeEventLog2({
          abi: jobManagerAbi_default,
          data: log.data,
          topics: log.topics
        })
      );
      const createdJobEvent = contractLogs.find(
        (log) => log.eventName === "JobCreated" && log.args.client.toLowerCase() === clientAddress.toLowerCase() && log.args.provider.toLowerCase() === providerAddress.toLowerCase()
      );
      if (!createdJobEvent) {
        throw new acpError_default("Failed to find created job event");
      }
      return Number(createdJobEvent.args.jobId);
    });
  }
  updateJobX402Nonce(jobId, nonce) {
    return __async(this, null, function* () {
      return yield this.acpX402.updateJobNonce(jobId, nonce);
    });
  }
  generateX402Payment(payableRequest, requirements) {
    return __async(this, null, function* () {
      return yield this.acpX402.generatePayment(payableRequest, requirements);
    });
  }
  performX402Request(url, version2, budget, signature) {
    return __async(this, null, function* () {
      return yield this.acpX402.performRequest(url, version2, budget, signature);
    });
  }
  getX402PaymentDetails(jobId) {
    return __async(this, null, function* () {
      try {
        const result = yield this.publicClient.readContract({
          address: this.jobManagerAddress,
          abi: jobManagerAbi_default,
          functionName: "x402PaymentDetails",
          args: [BigInt(jobId)]
        });
        return {
          isX402: result[0],
          isBudgetReceived: result[1]
        };
      } catch (error) {
        throw new acpError_default("Failed to get X402 payment details", error);
      }
    });
  }
  getAcpVersion() {
    return "2";
  }
};
var acpContractClientV2_default = AcpContractClientV2;

// src/index.ts
var index_default = acpClient_default;
export {
  acpAbi_default as ACP_ABI,
  AcpAgentSort,
  acpContractClient_default as AcpContractClient,
  acpContractClientV2_default as AcpContractClientV2,
  AcpContractConfig2 as AcpContractConfig,
  acpError_default as AcpError,
  AcpGraduationStatus,
  acpJob_default as AcpJob,
  AcpJobPhases,
  acpMemo_default as AcpMemo,
  AcpMemoStatus,
  AcpOnlineStatus,
  baseAcpContractClient_default as BaseAcpContractClient,
  Fare,
  FareAmount,
  FareBigInt,
  MemoType,
  PayloadType,
  PositionDirection,
  baseAcpConfig,
  baseAcpConfigV2,
  baseAcpX402Config,
  baseAcpX402ConfigV2,
  baseSepoliaAcpConfig,
  baseSepoliaAcpConfigV2,
  index_default as default,
  ethFare,
  preparePayload,
  wethFare
};
