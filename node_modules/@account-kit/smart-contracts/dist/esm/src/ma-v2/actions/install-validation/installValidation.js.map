{"version":3,"file":"installValidation.js","sourceRoot":"","sources":["../../../../../../src/ma-v2/actions/install-validation/installValidation.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AccountNotFoundError,\n  NotAModularAccountV2Error,\n  EntityIdOverrideError,\n  type GetAccountParameter,\n  type GetEntryPointFromAccount,\n  IncompatibleClientError,\n  type SendUserOperationResult,\n  type UserOperationOverridesParameter,\n  isSmartAccountClient,\n  isSmartAccountWithSigner,\n} from \"@aa-sdk/core\";\nimport {\n  type Address,\n  type Chain,\n  type Client,\n  type Hex,\n  type Transport,\n  concatHex,\n  encodeFunctionData,\n  zeroAddress,\n} from \"viem\";\n\nimport { semiModularAccountBytecodeAbi } from \"../../abis/semiModularAccountBytecodeAbi.js\";\nimport type { HookConfig, ValidationConfig } from \"../common/types.js\";\nimport {\n  serializeHookConfig,\n  serializeModuleEntity,\n  serializeValidationConfig,\n} from \"../common/utils.js\";\n\nimport {\n  type ModularAccountsV2,\n  isModularAccountV2,\n} from \"../../account/common/modularAccountV2Base.js\";\nimport { DEFAULT_OWNER_ENTITY_ID } from \"../../utils.js\";\n\nexport type InstallValidationParams<\n  TAccount extends ModularAccountsV2 | undefined =\n    | ModularAccountsV2\n    | undefined,\n> = {\n  validationConfig: ValidationConfig;\n  selectors: Hex[];\n  installData: Hex;\n  hooks: {\n    hookConfig: HookConfig;\n    initData: Hex;\n  }[];\n} & UserOperationOverridesParameter<GetEntryPointFromAccount<TAccount>> &\n  GetAccountParameter<TAccount>;\n\nexport type UninstallValidationParams<\n  TAccount extends ModularAccountsV2 | undefined =\n    | ModularAccountsV2\n    | undefined,\n> = {\n  moduleAddress: Address;\n  entityId: number;\n  uninstallData: Hex;\n  hookUninstallDatas: Hex[];\n} & UserOperationOverridesParameter<GetEntryPointFromAccount<TAccount>> &\n  GetAccountParameter<TAccount>;\n\nexport type InstallValidationActions<\n  TAccount extends ModularAccountsV2 | undefined =\n    | ModularAccountsV2\n    | undefined,\n> = {\n  installValidation: (\n    args: InstallValidationParams<TAccount>,\n  ) => Promise<SendUserOperationResult>;\n  encodeInstallValidation: (\n    // TODO: omit the user op sending related parameters from this type\n    args: InstallValidationParams<TAccount>,\n  ) => Promise<Hex>;\n  uninstallValidation: (\n    args: UninstallValidationParams<TAccount>,\n  ) => Promise<SendUserOperationResult>;\n  encodeUninstallValidation: (\n    args: UninstallValidationParams<TAccount>,\n  ) => Promise<Hex>;\n};\n\n/**\n * Provides validation installation and uninstallation functionalities for a MA v2 client, ensuring compatibility with `SmartAccountClient`.\n *\n * @example\n * ```ts\n * import { createModularAccountV2Client, installValidationActions, getDefaultSingleSignerValidationModuleAddress, SingleSignerValidationModule } from \"@account-kit/smart-contracts\";\n * import { Address } from \"viem\";\n *\n * const client = (await createModularAccountV2Client({ ... })).extend(installValidationActions);\n * const sessionKeyAddress: Address = \"0x1234\";\n * const sessionKeyEntityId: number = 1;\n *\n * await client.installValidation({\n *   validationConfig: {\n *     moduleAddress: getDefaultSingleSignerValidationModuleAddress(\n *       client.chain\n *     ),\n *     entityId: sessionKeyEntityId,\n *     isGlobal: true,\n *     isSignatureValidation: false,\n *     isUserOpValidation: true,\n *   },\n *   selectors: [],\n *   installData: SingleSignerValidationModule.encodeOnInstallData({\n *     entityId: sessionKeyEntityId,\n *     signer: sessionKeyAddress,\n *   }),\n *   hooks: [],\n * });\n *\n * await client.uninstallValidation({\n *   moduleAddress: sessionKeyAddress,\n *   entityId: sessionKeyEntityId,\n *   uninstallData: SingleSignerValidationModule.encodeOnUninstallData({\n *     entityId: sessionKeyEntityId,\n *   }),\n *   hookUninstallDatas: [],\n * });\n *\n * ```\n *\n * @param {object} client - The client instance which provides account and sendUserOperation functionality.\n * @returns {object} - An object containing two methods, `installValidation` and `uninstallValidation`.\n */\nexport function installValidationActions<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends ModularAccountsV2 | undefined =\n    | ModularAccountsV2\n    | undefined,\n>(\n  client: Client<TTransport, TChain, TAccount>,\n): InstallValidationActions<TAccount> {\n  const encodeInstallValidation = async ({\n    validationConfig,\n    selectors,\n    installData,\n    hooks,\n    account = client.account,\n  }: InstallValidationParams<TAccount>) => {\n    if (!account) {\n      throw new AccountNotFoundError();\n    }\n\n    if (!isModularAccountV2(account)) {\n      throw new NotAModularAccountV2Error();\n    }\n\n    if (isSmartAccountWithSigner(account) && !isSmartAccountClient(client)) {\n      // if we don't differentiate between WebauthnModularAccountV2Client and ModularAccountV2Client, passing client to isSmartAccountClient complains\n      throw new IncompatibleClientError(\n        \"SmartAccountClient\",\n        \"installValidation\",\n        client,\n      );\n    }\n\n    // an entityId of zero is only allowed if we're installing or uninstalling hooks on the fallback validation\n    if (\n      validationConfig.entityId === DEFAULT_OWNER_ENTITY_ID &&\n      validationConfig.moduleAddress !== zeroAddress\n    ) {\n      throw new EntityIdOverrideError();\n    }\n\n    return account.encodeCallData(\n      encodeFunctionData({\n        abi: semiModularAccountBytecodeAbi,\n        functionName: \"installValidation\",\n        args: [\n          serializeValidationConfig(validationConfig),\n          selectors,\n          installData,\n          hooks.map((hook: { hookConfig: HookConfig; initData: Hex }) =>\n            concatHex([serializeHookConfig(hook.hookConfig), hook.initData]),\n          ),\n        ],\n      }),\n    );\n  };\n\n  const encodeUninstallValidation = async ({\n    moduleAddress,\n    entityId,\n    uninstallData,\n    hookUninstallDatas,\n    account = client.account,\n  }: UninstallValidationParams<TAccount>) => {\n    if (!account) {\n      throw new AccountNotFoundError();\n    }\n\n    if (!isModularAccountV2(account)) {\n      throw new NotAModularAccountV2Error();\n    }\n\n    if (isSmartAccountWithSigner(account) && !isSmartAccountClient(client)) {\n      // if we don't differentiate between WebauthnModularAccountV2Client and ModularAccountV2Client, passing client to isSmartAccountClient complains\n      throw new IncompatibleClientError(\n        \"SmartAccountClient\",\n        \"uninstallValidation\",\n        client,\n      );\n    }\n\n    return account.encodeCallData(\n      encodeFunctionData({\n        abi: semiModularAccountBytecodeAbi,\n        functionName: \"uninstallValidation\",\n        args: [\n          serializeModuleEntity({\n            moduleAddress,\n            entityId,\n          }),\n          uninstallData,\n          hookUninstallDatas,\n        ],\n      }),\n    );\n  };\n\n  return {\n    encodeInstallValidation,\n    encodeUninstallValidation,\n    installValidation: async ({\n      validationConfig,\n      selectors,\n      installData,\n      hooks,\n      account = client.account,\n      overrides,\n    }: InstallValidationParams<TAccount>) => {\n      if (!isSmartAccountClient(client)) {\n        throw new IncompatibleClientError(\n          \"SmartAccountClient\",\n          \"installValidation\",\n          client,\n        );\n      }\n\n      if (!account) {\n        throw new AccountNotFoundError();\n      }\n\n      const callData = await encodeInstallValidation({\n        validationConfig,\n        selectors,\n        installData,\n        hooks,\n        account,\n      });\n\n      return client.sendUserOperation({\n        uo: callData,\n        account,\n        overrides,\n      });\n    },\n\n    uninstallValidation: async ({\n      moduleAddress,\n      entityId,\n      uninstallData,\n      hookUninstallDatas,\n      account = client.account,\n      overrides,\n    }: UninstallValidationParams<TAccount>) => {\n      if (!account) {\n        throw new AccountNotFoundError();\n      }\n\n      if (!isSmartAccountClient(client)) {\n        throw new IncompatibleClientError(\n          \"SmartAccountClient\",\n          \"uninstallValidation\",\n          client,\n        );\n      }\n\n      const callData: Hex = await encodeUninstallValidation({\n        moduleAddress,\n        entityId,\n        uninstallData,\n        hookUninstallDatas,\n        account,\n      });\n\n      return client.sendUserOperation({\n        uo: callData,\n        account,\n        overrides,\n      });\n    },\n  };\n}\n"]}