{"version":3,"file":"base.js","sourceRoot":"","sources":["../../../../../src/light-account/accounts/base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  FailedToGetStorageSlotError,\n  createBundlerClient,\n  toSmartContractAccount,\n  type Abi,\n  type EntryPointDef,\n  type SmartAccountSigner,\n  type SmartContractAccountWithSigner,\n  type ToSmartContractAccountParams,\n  type UpgradeToAndCallParams,\n} from \"@aa-sdk/core\";\nimport {\n  concat,\n  encodeFunctionData,\n  fromHex,\n  hashMessage,\n  hashTypedData,\n  trim,\n  type Address,\n  type Chain,\n  type Hex,\n  type Transport,\n  type TypedData,\n  type TypedDataDefinition,\n} from \"viem\";\nimport type {\n  LightAccountEntryPointVersion,\n  LightAccountType,\n  LightAccountVersion,\n} from \"../types.js\";\nimport { AccountVersionRegistry } from \"../utils.js\";\nimport type { SignatureRequest } from \"@aa-sdk/core\";\n\nenum SignatureType {\n  EOA = \"0x00\",\n  CONTRACT = \"0x01\",\n  CONTRACT_WITH_ADDR = \"0x02\",\n}\n\nexport type LightAccountBase<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n  TLightAccountType extends LightAccountType = LightAccountType,\n  TLightAccountVersion extends\n    LightAccountVersion<TLightAccountType> = LightAccountVersion<TLightAccountType>,\n> = SmartContractAccountWithSigner<\n  TLightAccountType,\n  TSigner,\n  LightAccountEntryPointVersion<TLightAccountType, TLightAccountVersion>\n> & {\n  getLightAccountVersion: () => TLightAccountVersion;\n};\n\n//#region CreateLightAccountBaseParams\nexport type CreateLightAccountBaseParams<\n  TLightAccountType extends LightAccountType,\n  TLightAccountVersion extends\n    LightAccountVersion<TLightAccountType> = LightAccountVersion<TLightAccountType>,\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n> = Pick<\n  ToSmartContractAccountParams<TLightAccountType, TTransport, Chain>,\n  \"transport\" | \"chain\" | \"getAccountInitCode\"\n> & {\n  abi: Abi;\n  signer: TSigner;\n  accountAddress: Address;\n  type: TLightAccountType;\n  version: TLightAccountVersion;\n  entryPoint: EntryPointDef<\n    LightAccountEntryPointVersion<TLightAccountType, TLightAccountVersion>,\n    Chain\n  >;\n};\n//#endregion CreateLightAccountBaseParams\n\nexport async function createLightAccountBase<\n  TLightAccountType extends LightAccountType,\n  TLightAccountVersion extends LightAccountVersion<TLightAccountType>,\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n>({\n  transport,\n  chain,\n  signer,\n  abi,\n  version,\n  type,\n  entryPoint,\n  accountAddress,\n  getAccountInitCode,\n}: CreateLightAccountBaseParams<\n  TLightAccountType,\n  TLightAccountVersion,\n  TTransport,\n  TSigner\n>): Promise<\n  LightAccountBase<TSigner, TLightAccountType, TLightAccountVersion>\n> {\n  const client = createBundlerClient({\n    transport,\n    chain,\n  });\n\n  const encodeUpgradeToAndCall = async ({\n    upgradeToAddress,\n    upgradeToInitData,\n  }: UpgradeToAndCallParams): Promise<Hex> => {\n    const storage = await client.getStorageAt({\n      address: accountAddress,\n      // the slot at which impl addresses are stored by UUPS\n      slot: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n    });\n\n    if (storage == null) {\n      throw new FailedToGetStorageSlotError(\n        \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n        \"Proxy Implementation Address\",\n      );\n    }\n\n    const implementationAddresses = Object.values(\n      AccountVersionRegistry[type],\n    ).map(\n      (x) =>\n        x.addresses.overrides?.[chain.id]?.impl ?? x.addresses.default.impl,\n    );\n\n    // only upgrade undeployed accounts (storage 0) or deployed light accounts, error otherwise\n    if (\n      fromHex(storage, \"number\") !== 0 &&\n      !implementationAddresses.some((x) => x === trim(storage))\n    ) {\n      throw new Error(\n        `could not determine if smart account implementation is ${type} ${String(\n          version,\n        )}`,\n      );\n    }\n\n    return encodeFunctionData({\n      abi,\n      functionName: \"upgradeToAndCall\",\n      args: [upgradeToAddress, upgradeToInitData],\n    });\n  };\n\n  const get1271Wrapper = (\n    hashedMessage: Hex,\n    version: string,\n  ): TypedDataDefinition => {\n    return {\n      // EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\n      // https://github.com/alchemyplatform/light-account/blob/main/src/LightAccount.sol#L236\n      domain: {\n        chainId: Number(client.chain.id),\n        name: type,\n        verifyingContract: accountAddress,\n        version,\n      },\n      types: {\n        LightAccountMessage: [{ name: \"message\", type: \"bytes\" }],\n      },\n      message: {\n        message: hashedMessage,\n      },\n      primaryType: \"LightAccountMessage\",\n    };\n  };\n\n  const prepareSign = async (\n    params: SignatureRequest,\n  ): Promise<SignatureRequest> => {\n    const messageHash =\n      params.type === \"personal_sign\"\n        ? hashMessage(params.data)\n        : hashTypedData(params.data);\n\n    switch (version as string) {\n      case \"v1.0.1\":\n        return params;\n      case \"v1.0.2\":\n        throw new Error(\n          `Version ${String(version)} of LightAccount doesn't support 1271`,\n        );\n      case \"v1.1.0\":\n        return {\n          type: \"eth_signTypedData_v4\",\n          data: get1271Wrapper(messageHash, \"1\"),\n        };\n      case \"v2.0.0\":\n        return {\n          type: \"eth_signTypedData_v4\",\n          data: get1271Wrapper(messageHash, \"2\"),\n        };\n      default:\n        throw new Error(`Unknown version ${String(version)} of LightAccount`);\n    }\n  };\n\n  const formatSign = async (\n    signature: `0x${string}`,\n  ): Promise<`0x${string}`> => {\n    return version === \"v2.0.0\"\n      ? concat([SignatureType.EOA, signature])\n      : signature;\n  };\n\n  const account = await toSmartContractAccount({\n    transport,\n    chain,\n    entryPoint,\n    accountAddress,\n    source: type,\n    getAccountInitCode,\n    prepareSign,\n    formatSign,\n    encodeExecute: async ({ target, data, value }) => {\n      return encodeFunctionData({\n        abi,\n        functionName: \"execute\",\n        args: [target, value ?? 0n, data],\n      });\n    },\n    encodeBatchExecute: async (txs) => {\n      const [targets, values, datas] = txs.reduce(\n        (accum, curr) => {\n          accum[0].push(curr.target);\n          accum[1].push(curr.value ?? 0n);\n          accum[2].push(curr.data);\n\n          return accum;\n        },\n        [[], [], []] as [Address[], bigint[], Hex[]],\n      );\n      return encodeFunctionData({\n        abi,\n        functionName: \"executeBatch\",\n        args: [targets, values, datas],\n      });\n    },\n    signUserOperationHash: async (uoHash: Hex) => {\n      const signature = await signer.signMessage({ raw: uoHash });\n      switch (version) {\n        case \"v2.0.0\":\n          // TODO: handle case where signer is an SCA.\n          return concat([SignatureType.EOA, signature]);\n        default:\n          return signature;\n      }\n    },\n    async signMessage({ message }) {\n      const { type, data } = await prepareSign({\n        type: \"personal_sign\",\n        data: message,\n      });\n\n      const sig =\n        type === \"personal_sign\"\n          ? await signer.signMessage(data)\n          : await signer.signTypedData(data);\n\n      return formatSign(sig);\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(params: TypedDataDefinition<typedData, primaryType>) {\n      const { type, data } = await prepareSign({\n        type: \"eth_signTypedData_v4\",\n        data: params as TypedDataDefinition,\n      });\n\n      const sig =\n        type === \"personal_sign\"\n          ? await signer.signMessage(data)\n          : await signer.signTypedData(data);\n\n      return formatSign(sig);\n    },\n    getDummySignature: (): Hex => {\n      const signature =\n        \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n      switch (version as string) {\n        case \"v1.0.1\":\n        case \"v1.0.2\":\n        case \"v1.1.0\":\n          return signature;\n        case \"v2.0.0\":\n          return concat([SignatureType.EOA, signature]);\n        default:\n          throw new Error(`Unknown version ${type} of ${String(version)}`);\n      }\n    },\n    encodeUpgradeToAndCall,\n  });\n\n  return {\n    ...account,\n    source: type,\n    getLightAccountVersion: () => version,\n    getSigner: () => signer,\n  };\n}\n"]}