import { concatHex, toHex, zeroHash } from "viem";
import { isSmartAccountWithSigner, } from "../../../account/smartContractAccount.js";
import { AccountNotFoundError } from "../../../errors/account.js";
import { ChainNotFoundError } from "../../../errors/client.js";
import { conditionalReturn } from "../../../utils/index.js";
/**
 * Description internal action function of SmartAccountClient for initializing
 * a user operation for the sender account
 *
 * @template {Transport} TTransport
 * @template {Chain | undefined} TChain
 * @template {SmartContractAccount | undefined} TAccount
 * @template {UserOperationContext | undefined} TContext
 * @template {GetEntryPointFromAccount} TEntryPointVersion
 * @param {BaseSmartAccountClient<TTransport, TChain, TAccount>} client smart account client
 * @param {SendUserOperationParameters<TAccount, TContext, TEntryPointVersion> | BuildUserOperationParameters<TAccount, TContext, TEntryPointVersion>} args send user operation parameters
 * @returns {Promise<Deferrable<UserOperationStruct<TEntryPointVersion>>>} initialized user operation struct
 */
export async function _initUserOperation(client, args) {
    const { account = client.account, uo, overrides } = args;
    if (!account) {
        throw new AccountNotFoundError();
    }
    if (!client.chain) {
        throw new ChainNotFoundError();
    }
    const entryPoint = account.getEntryPoint();
    const callData = Array.isArray(uo)
        ? account.encodeBatchExecute(uo)
        : typeof uo === "string"
            ? uo
            : account.encodeExecute(uo);
    const signature = account.getDummySignature();
    const nonce = overrides?.nonce ?? account.getAccountNonce(overrides?.nonceKey);
    const struct = entryPoint.version === "0.6.0"
        ? {
            initCode: account.getInitCode(),
            sender: account.address,
            nonce,
            callData,
            signature,
        }
        : {
            factory: conditionalReturn(account.isAccountDeployed().then((deployed) => !deployed), account.getFactoryAddress),
            factoryData: conditionalReturn(account.isAccountDeployed().then((deployed) => !deployed), account.getFactoryData),
            sender: account.address,
            nonce,
            callData,
            signature,
        };
    const is7702 = account.source === "ModularAccountV2" &&
        isSmartAccountWithSigner(account) &&
        (await account.getSigner().getAddress()).toLowerCase() ===
            account.address.toLowerCase();
    if (is7702) {
        if (entryPoint.version !== "0.7.0") {
            throw new Error("7702 is only compatible with EntryPoint v0.7.0");
        }
        const [implementationAddress, code = "0x", nonce] = await Promise.all([
            account.getImplementationAddress(),
            client.getCode({ address: account.address }),
            client.getTransactionCount({ address: account.address }),
        ]);
        const isAlreadyDelegated = code.toLowerCase() ===
            concatHex(["0xef0100", implementationAddress]).toLowerCase();
        if (!isAlreadyDelegated) {
            struct.eip7702Auth = {
                chainId: toHex(client.chain.id),
                nonce: toHex(nonce),
                address: implementationAddress,
                r: zeroHash, // aka `bytes32(0)`
                s: zeroHash,
                yParity: "0x0",
            };
        }
    }
    return struct;
}
//# sourceMappingURL=initUserOperation.js.map