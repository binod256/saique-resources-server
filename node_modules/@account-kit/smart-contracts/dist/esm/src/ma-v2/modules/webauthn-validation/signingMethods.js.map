{"version":3,"file":"signingMethods.js","sourceRoot":"","sources":["../../../../../../src/ma-v2/modules/webauthn-validation/signingMethods.ts"],"names":[],"mappings":"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","sourcesContent":["import * as WebAuthnP256 from \"ox/WebAuthnP256\";\nimport {\n  type Address,\n  type Chain,\n  concatHex,\n  encodeAbiParameters,\n  hashMessage,\n  hashTypedData,\n  type Hex,\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n} from \"viem\";\nimport { type ToWebAuthnAccountParameters } from \"viem/account-abstraction\";\nimport {\n  assertNever,\n  isDeferredAction,\n  pack1271WebAuthnSignature,\n} from \"../../utils.js\";\nimport { getDefaultWebauthnValidationModuleAddress } from \"../utils.js\";\nimport type { SignatureRequest, SigningMethods } from \"@aa-sdk/core\";\n\n/**\n * Creates an object with methods for generating a dummy signature, signing user operation hashes, signing messages, and signing typed data.\n *\n * @example \n \n * ```ts\n * import { webauthnSigningFunctions } from \"@account-kit/smart-contracts\";\n * import { LocalAccountSigner } from \"@aa-sdk/core\";\n *\n * const messageSigner = webauthnSigningFunctions(credential, getFn, rpId, chain, account.address, account.signerEntity.entityId);\n * ```\n *\n * @param {ToWebAuthnAccountParameters} credential the Webauthn public key credential object\n * @param {ToWebAuthnAccountParameters[\"getFn\"]} getFn function to retrieve the WebAuthn credential\n * @param {ToWebAuthnAccountParameters[\"rpId\"]} rpId the relying party ID for the WebAuthn credential\n * @param {Chain} chain Chain object for the signer\n * @param {Address} accountAddress address of the smart account using this signer\n * @param {number} entityId the entity id of the signing validation\n * @param {Hex} deferredActionData optional deferred action data to prepend to the uo signatures\n * @returns {object} an object with methods for signing operations and managing signatures\n */\nexport const webauthnSigningFunctions = (\n  credential: ToWebAuthnAccountParameters[\"credential\"],\n  getFn: ToWebAuthnAccountParameters[\"getFn\"],\n  rpId: ToWebAuthnAccountParameters[\"rpId\"],\n  chain: Chain,\n  accountAddress: Address,\n  entityId: number,\n  deferredActionData?: Hex,\n) => {\n  const { id, publicKey } = credential;\n\n  const sign = async ({ hash }: { hash: Hex }) => {\n    const { metadata, signature } = await WebAuthnP256.sign({\n      credentialId: id,\n      getFn,\n      challenge: hash,\n      rpId,\n    });\n\n    return encodeAbiParameters(\n      [\n        {\n          name: \"params\",\n          type: \"tuple\",\n          components: [\n            { name: \"authenticatorData\", type: \"bytes\" },\n            { name: \"clientDataJSON\", type: \"string\" },\n            { name: \"challengeIndex\", type: \"uint256\" },\n            { name: \"typeIndex\", type: \"uint256\" },\n            { name: \"r\", type: \"uint256\" },\n            { name: \"s\", type: \"uint256\" },\n          ],\n        },\n      ],\n      [\n        {\n          authenticatorData: metadata.authenticatorData,\n          clientDataJSON: metadata.clientDataJSON,\n          challengeIndex: BigInt(metadata.challengeIndex),\n          typeIndex: BigInt(metadata.typeIndex),\n          r: signature.r,\n          s: signature.s,\n        },\n      ],\n    );\n  };\n\n  const signingMethods: SigningMethods = {\n    prepareSign: async (\n      request: SignatureRequest,\n    ): Promise<SignatureRequest> => {\n      const requestType = request.type;\n      let hash;\n\n      switch (requestType) {\n        case \"personal_sign\":\n          hash = hashMessage(request.data);\n          break;\n\n        case \"eth_signTypedData_v4\":\n          if (isDeferredAction(request.data, accountAddress)) {\n            return request;\n          } else {\n            hash = hashTypedData(request.data);\n            break;\n          }\n\n        default:\n          return assertNever(requestType, \"Invalid signature request type\");\n      }\n\n      return {\n        type: \"eth_signTypedData_v4\",\n        data: {\n          domain: {\n            chainId: Number(chain.id),\n            verifyingContract: getDefaultWebauthnValidationModuleAddress(chain),\n            salt: concatHex([`0x${\"00\".repeat(12)}`, accountAddress]),\n          },\n          types: {\n            ReplaySafeHash: [{ name: \"hash\", type: \"bytes32\" }],\n          },\n          message: {\n            hash,\n          },\n          primaryType: \"ReplaySafeHash\",\n        },\n      };\n    },\n    formatSign: async (signature: Hex) => {\n      return pack1271WebAuthnSignature({\n        validationSignature: signature,\n        entityId,\n      });\n    },\n  };\n\n  return {\n    ...signingMethods,\n    id,\n    publicKey,\n    getDummySignature: (): Hex =>\n      \"0xff000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001949fc7c88032b9fcb5f6efc7a7b8c63668eae9871b765e23123bb473ff57aa831a7c0d9276168ebcc29f2875a0239cffdf2a9cd1c2007c5c77c071db9264df1d000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008a7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a2273496a396e6164474850596759334b7156384f7a4a666c726275504b474f716d59576f4d57516869467773222c226f726967696e223a2268747470733a2f2f7369676e2e636f696e626173652e636f6d222c2263726f73734f726967696e223a66616c73657d00000000000000000000000000000000000000000000\",\n    signUserOperationHash: async (uoHash: Hex): Promise<Hex> => {\n      let sig = await sign({ hash: hashMessage({ raw: uoHash }) });\n      if (deferredActionData) {\n        sig = concatHex([deferredActionData, sig]);\n        deferredActionData = undefined;\n      }\n\n      return concatHex([\"0xff\", sig]);\n    },\n\n    async signMessage({ message }: { message: SignableMessage }): Promise<Hex> {\n      const { data, type } = await signingMethods.prepareSign({\n        type: \"personal_sign\",\n        data: message,\n      });\n\n      if (type !== \"eth_signTypedData_v4\") {\n        throw new Error(\"Invalid signature request type\");\n      }\n\n      const signature = await sign({ hash: hashTypedData(data) });\n\n      return signingMethods.formatSign(signature);\n    },\n\n    signTypedData: async <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      typedDataDefinition: TypedDataDefinition<typedData, primaryType>,\n    ): Promise<Hex> => {\n      const { data, type } = await signingMethods.prepareSign({\n        type: \"eth_signTypedData_v4\",\n        data: typedDataDefinition as TypedDataDefinition,\n      });\n\n      if (type !== \"eth_signTypedData_v4\") {\n        throw new Error(\"Invalid signature request type\");\n      }\n\n      const signature = await sign({ hash: hashTypedData(data) });\n\n      return isDeferredAction(typedDataDefinition, accountAddress)\n        ? signature\n        : signingMethods.formatSign(signature);\n    },\n  };\n};\n"]}