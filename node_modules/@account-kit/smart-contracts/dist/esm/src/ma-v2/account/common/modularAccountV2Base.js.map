{"version":3,"file":"modularAccountV2Base.js","sourceRoot":"","sources":["../../../../../../src/ma-v2/account/common/modularAccountV2Base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BaseError,\n  createBundlerClient,\n  getEntryPoint,\n  InvalidDeferredActionNonce,\n  InvalidEntityIdError,\n  InvalidNonceKeyError,\n  toSmartContractAccount,\n  type AccountOp,\n  type SmartAccountSigner,\n  type SmartContractAccount,\n  type SmartContractAccountWithSigner,\n  type ToSmartContractAccountParams,\n} from \"@aa-sdk/core\";\nimport {\n  concatHex,\n  encodeFunctionData,\n  getContract,\n  maxUint152,\n  maxUint32,\n  zeroAddress,\n  isAddressEqual,\n  type Address,\n  type Chain,\n  type Hex,\n  type Transport,\n} from \"viem\";\nimport type { ToWebAuthnAccountParameters } from \"viem/account-abstraction\";\nimport { modularAccountAbi } from \"../../abis/modularAccountAbi.js\";\nimport { serializeModuleEntity } from \"../../actions/common/utils.js\";\nimport { singleSignerMessageSigner } from \"../../modules/single-signer-validation/signer.js\";\nimport { webauthnSigningFunctions } from \"../../modules/webauthn-validation/signingMethods.js\";\nimport { DEFAULT_OWNER_ENTITY_ID, parseDeferredAction } from \"../../utils.js\";\nimport { nativeSMASigner } from \"../nativeSMASigner.js\";\n\nexport const executeUserOpSelector: Hex = \"0x8DD7712F\";\n\nexport type ModularAccountsV2 = ModularAccountV2 | WebauthnModularAccountV2;\n\nexport type SignerEntity = {\n  isGlobalValidation: boolean;\n  entityId: number;\n};\n\nexport type ExecutionDataView = {\n  module: Address;\n  skipRuntimeValidation: boolean;\n  allowGlobalValidation: boolean;\n  executionHooks: readonly Hex[];\n};\n\nexport type ValidationDataView = {\n  validationHooks: readonly Hex[];\n  executionHooks: readonly Hex[];\n  selectors: readonly Hex[];\n  validationFlags: number;\n};\n\nexport type ValidationDataParams =\n  | {\n      validationModuleAddress: Address;\n      entityId?: never;\n    }\n  | {\n      validationModuleAddress?: never;\n      entityId: number;\n    };\n\nexport type ModularAccountV2<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n> = SmartContractAccountWithSigner<\"ModularAccountV2\", TSigner, \"0.7.0\"> & {\n  signerEntity: SignerEntity;\n  getExecutionData: (selector: Hex) => Promise<ExecutionDataView>;\n  getValidationData: (\n    args: ValidationDataParams,\n  ) => Promise<ValidationDataView>;\n  encodeCallData: (callData: Hex) => Promise<Hex>;\n};\n\nexport type WebauthnModularAccountV2 = SmartContractAccount<\n  \"ModularAccountV2\",\n  \"0.7.0\"\n> & {\n  params: ToWebAuthnAccountParameters;\n  signerEntity: SignerEntity;\n  getExecutionData: (selector: Hex) => Promise<ExecutionDataView>;\n  getValidationData: (\n    args: ValidationDataParams,\n  ) => Promise<ValidationDataView>;\n  encodeCallData: (callData: Hex) => Promise<Hex>;\n};\n\nexport type CreateMAV2BaseParams<\n  TSigner extends SmartAccountSigner | undefined =\n    | SmartAccountSigner\n    | undefined,\n  TTransport extends Transport = Transport,\n> = Omit<\n  ToSmartContractAccountParams<\"ModularAccountV2\", TTransport, Chain, \"0.7.0\">,\n  // Implements the following methods required by `toSmartContractAccount`, and passes through any other parameters.\n  | \"encodeExecute\"\n  | \"encodeBatchExecute\"\n  | \"getNonce\"\n  | \"signMessage\"\n  | \"signTypedData\"\n  | \"getDummySignature\"\n  | \"prepareSign\"\n  | \"formatSign\"\n> & {\n  signer: TSigner;\n  signerEntity?: SignerEntity;\n  accountAddress: Address;\n  deferredAction?: Hex;\n};\n\nexport type CreateWebauthnMAV2BaseParams = Omit<\n  CreateMAV2BaseParams,\n  \"signer\"\n> & {\n  credential: ToWebAuthnAccountParameters[\"credential\"];\n  getFn?: ToWebAuthnAccountParameters[\"getFn\"] | undefined;\n  rpId?: ToWebAuthnAccountParameters[\"rpId\"] | undefined;\n};\n\nexport type CreateMAV2BaseReturnType<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n> = Promise<ModularAccountV2<TSigner>>;\n\n// function overload\nexport async function createMAv2Base(\n  config: CreateWebauthnMAV2BaseParams,\n): Promise<WebauthnModularAccountV2>;\n\nexport async function createMAv2Base<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n>(config: CreateMAV2BaseParams): CreateMAV2BaseReturnType<TSigner>;\n\nexport async function createMAv2Base<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n>(\n  config: CreateMAV2BaseParams<TSigner> | CreateWebauthnMAV2BaseParams,\n): Promise<WebauthnModularAccountV2 | ModularAccountV2<TSigner>> {\n  let {\n    transport,\n    chain,\n    entryPoint = getEntryPoint(chain, { version: \"0.7.0\" }),\n    signerEntity = {\n      isGlobalValidation: true,\n      entityId: DEFAULT_OWNER_ENTITY_ID,\n    },\n    signerEntity: {\n      isGlobalValidation = true,\n      entityId = DEFAULT_OWNER_ENTITY_ID,\n    } = {},\n    accountAddress,\n    deferredAction,\n    ...remainingToSmartContractAccountParams\n  } = config;\n\n  const signer = \"signer\" in config ? config.signer : undefined;\n  const credential = \"credential\" in config ? config.credential : undefined;\n  const getFn = \"getFn\" in config ? config.getFn : undefined;\n  const rpId = \"rpId\" in config ? config.rpId : undefined;\n\n  if (entityId > Number(maxUint32)) {\n    throw new InvalidEntityIdError(entityId);\n  }\n\n  const client = createBundlerClient({\n    transport,\n    chain,\n  });\n\n  const entryPointContract = getContract({\n    address: entryPoint.address,\n    abi: entryPoint.abi,\n    client,\n  });\n\n  // These default values signal that we should not use the set deferred action nonce\n  let nonce: bigint | undefined;\n  let deferredActionData: Hex | undefined;\n  let hasAssociatedExecHooks: boolean = false;\n\n  if (deferredAction) {\n    let deferredActionNonce: bigint = 0n;\n    // We always update entity id and isGlobalValidation to the deferred action value since the client could be used to send multiple calls\n    ({\n      entityId,\n      isGlobalValidation,\n      nonce: deferredActionNonce,\n    } = parseDeferredAction(deferredAction));\n\n    // Set these values if the deferred action has not been consumed. We check this with the EP\n    const nextNonceForDeferredAction: bigint =\n      (await entryPointContract.read.getNonce([\n        accountAddress,\n        deferredActionNonce >> 64n,\n      ])) as bigint;\n\n    if (deferredActionNonce === nextNonceForDeferredAction) {\n      ({ nonce, deferredActionData, hasAssociatedExecHooks } =\n        parseDeferredAction(deferredAction));\n    } else if (deferredActionNonce > nextNonceForDeferredAction) {\n      // if nonce is greater than the next nonce, its invalid, so we throw\n      throw new InvalidDeferredActionNonce();\n    }\n  }\n\n  const encodeExecute: (tx: AccountOp) => Promise<Hex> = async ({\n    target,\n    data,\n    value,\n  }) =>\n    await encodeCallData(\n      !isAddressEqual(target, accountAddress)\n        ? encodeFunctionData({\n            abi: modularAccountAbi,\n            functionName: \"execute\",\n            args: [target, value ?? 0n, data],\n          })\n        : data, // If the target is the same as the account address, we don't need to wrap in a call to `execute`.\n    );\n\n  const encodeBatchExecute: (txs: AccountOp[]) => Promise<Hex> = async (txs) =>\n    await encodeCallData(\n      encodeFunctionData({\n        abi: modularAccountAbi,\n        functionName: \"executeBatch\",\n        args: [\n          txs.map((tx) => ({\n            target: tx.target,\n            data: tx.data,\n            value: tx.value ?? 0n,\n          })),\n        ],\n      }),\n    );\n\n  const isAccountDeployed: () => Promise<boolean> = async () => {\n    const code = (\n      await client.getCode({ address: accountAddress })\n    )?.toLowerCase();\n    const is7702Delegated = code?.startsWith(\"0xef0100\");\n\n    if (!is7702Delegated) {\n      return !!code;\n    }\n\n    if (!config.getImplementationAddress) {\n      // Edge case where account is already delegated to a 3rd party\n      // implementation, but the MAv2 client is initialized using its\n      // address without specifying 7702 mode.\n      throw new BaseError(\n        \"Account is an already-delegated 7702 account, but client is missing implementation address. Be sure to initialize the client in 7702 mode.\",\n      );\n    }\n\n    const expectedCode = concatHex([\n      \"0xef0100\",\n      await config.getImplementationAddress(),\n    ]).toLowerCase();\n    return code === expectedCode;\n  };\n\n  const getNonce = async (nonceKey: bigint = 0n): Promise<bigint> => {\n    if (nonce) {\n      const tempNonce = nonce;\n      nonce = undefined; // set to falsy value once used\n      return tempNonce;\n    }\n\n    if (nonceKey > maxUint152) {\n      throw new InvalidNonceKeyError(nonceKey);\n    }\n\n    const fullNonceKey: bigint =\n      (nonceKey << 40n) +\n      (BigInt(entityId) << 8n) +\n      (isGlobalValidation ? 1n : 0n);\n\n    return entryPointContract.read.getNonce([\n      accountAddress,\n      fullNonceKey,\n    ]) as Promise<bigint>;\n  };\n\n  const accountContract = getContract({\n    address: accountAddress,\n    abi: modularAccountAbi,\n    client,\n  });\n\n  const getExecutionData = async (selector: Hex) => {\n    // Start both promises in parallel\n    const deployStatusPromise = isAccountDeployed();\n    const executionDataPromise = accountContract.read\n      .getExecutionData([selector])\n      .catch((error) => {\n        // Store the original error for potential re-throwing\n        // If the account is not deployed, we will get an error here that we want to swallow.\n        // Otherwise, we will re-throw the error.\n        return { error };\n      });\n\n    // Check if account is deployed first\n    const deployStatus = await deployStatusPromise;\n\n    if (deployStatus === false) {\n      return {\n        module: zeroAddress,\n        skipRuntimeValidation: false,\n        allowGlobalValidation: false,\n        executionHooks: [],\n      };\n    }\n\n    // Only await execution data if account is deployed\n    const executionData = await executionDataPromise;\n    if (\"error\" in executionData) {\n      throw executionData.error;\n    }\n    return executionData;\n  };\n\n  const getValidationData = async (args: ValidationDataParams) => {\n    const { validationModuleAddress, entityId } = args;\n\n    // Start both promises in parallel\n    const deployStatusPromise = isAccountDeployed();\n    const validationDataPromise = accountContract.read\n      .getValidationData([\n        serializeModuleEntity({\n          moduleAddress: validationModuleAddress ?? zeroAddress,\n          entityId: entityId ?? Number(maxUint32),\n        }),\n      ])\n      .catch((error) => {\n        // Store the original error for potential re-throwing\n        // If the account is not deployed, we will get an error here that we want to swallow.\n        // Otherwise, we will re-throw the error.\n        return { error };\n      });\n\n    // Check if account is deployed first\n    const deployStatus = await deployStatusPromise;\n\n    if (deployStatus === false) {\n      return {\n        validationHooks: [],\n        executionHooks: [],\n        selectors: [],\n        validationFlags: 0,\n      };\n    }\n\n    // Only await validation data if account is deployed\n    const validationData = await validationDataPromise;\n    if (\"error\" in validationData) {\n      throw validationData.error;\n    }\n    return validationData;\n  };\n\n  const encodeCallData = async (callData: Hex): Promise<Hex> => {\n    const validationData = await getValidationData({\n      entityId: Number(entityId),\n    });\n    if (hasAssociatedExecHooks) {\n      hasAssociatedExecHooks = false; // set to falsy value once used\n      return concatHex([executeUserOpSelector, callData]);\n    }\n    if (validationData.executionHooks.length) {\n      return concatHex([executeUserOpSelector, callData]);\n    }\n    return callData;\n  };\n\n  const baseAccount = await toSmartContractAccount({\n    ...remainingToSmartContractAccountParams,\n    transport,\n    chain,\n    entryPoint,\n    accountAddress,\n    encodeExecute,\n    encodeBatchExecute,\n    getNonce,\n    ...(signer\n      ? entityId === DEFAULT_OWNER_ENTITY_ID\n        ? nativeSMASigner(signer, chain, accountAddress, deferredActionData)\n        : singleSignerMessageSigner(\n            signer,\n            chain,\n            accountAddress,\n            entityId,\n            deferredActionData,\n          )\n      : webauthnSigningFunctions(\n          // credential required for webauthn mode is checked at modularAccountV2 creation level\n          credential!,\n          getFn,\n          rpId,\n          chain,\n          accountAddress,\n          entityId,\n          deferredActionData,\n        )),\n  });\n\n  if (!signer) {\n    return {\n      ...baseAccount,\n      signerEntity,\n      getExecutionData,\n      getValidationData,\n      encodeCallData,\n    } as WebauthnModularAccountV2; // TO DO: figure out when this breaks! we shouldn't have to cast\n  }\n\n  return {\n    ...baseAccount,\n    getSigner: () => signer,\n    signerEntity,\n    getExecutionData,\n    getValidationData,\n    encodeCallData,\n  } as ModularAccountV2<TSigner>; // TO DO: figure out when this breaks! we shouldn't have to cast\n}\n\nexport function isModularAccountV2(\n  account: SmartContractAccount,\n): account is ModularAccountV2 | WebauthnModularAccountV2 {\n  return account.source === \"ModularAccountV2\";\n}\n"]}