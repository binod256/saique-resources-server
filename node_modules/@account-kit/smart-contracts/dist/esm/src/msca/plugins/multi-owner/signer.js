import { hashMessage, hashTypedData, } from "viem";
import { MultiOwnerPlugin, MultiOwnerPluginAbi } from "./plugin.js";
export const multiOwnerMessageSigner = (client, accountAddress, signer, pluginAddress = MultiOwnerPlugin.meta.addresses[client.chain.id]) => {
    const get712Wrapper = async (msg) => {
        const [, name, version, chainId, verifyingContract, salt] = await client.readContract({
            abi: MultiOwnerPluginAbi,
            address: pluginAddress,
            functionName: "eip712Domain",
            account: accountAddress,
        });
        return {
            domain: {
                chainId: Number(chainId),
                name,
                salt,
                verifyingContract,
                version,
            },
            types: {
                AlchemyModularAccountMessage: [{ name: "message", type: "bytes" }],
            },
            message: {
                message: msg,
            },
            primaryType: "AlchemyModularAccountMessage",
        };
    };
    const prepareSign = async (params) => {
        const data = await get712Wrapper(params.type === "personal_sign"
            ? hashMessage(params.data)
            : hashTypedData(params.data));
        return {
            type: "eth_signTypedData_v4",
            data,
        };
    };
    const formatSign = async (signature) => {
        return signature;
    };
    return {
        prepareSign,
        formatSign,
        getDummySignature: () => {
            return "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
        },
        signUserOperationHash: (uoHash) => {
            return signer().signMessage({ raw: uoHash });
        },
        async signMessage({ message, }) {
            const { type, data } = await prepareSign({
                type: "personal_sign",
                data: message,
            });
            return type === "personal_sign"
                ? signer().signMessage(data)
                : signer().signTypedData(data);
        },
        signTypedData: async (typedDataDefinition) => {
            const { type, data } = await prepareSign({
                type: "eth_signTypedData_v4",
                data: typedDataDefinition,
            });
            return type === "personal_sign"
                ? signer().signMessage(data)
                : signer().signTypedData(data);
        },
    };
};
//# sourceMappingURL=signer.js.map